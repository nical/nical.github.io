<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Eight million pixels and counting - lyon, rust</title><link href="https://nical.github.io/" rel="alternate"></link><link href="https://nical.github.io/feeds/lyon-rust.atom.xml" rel="self"></link><id>https://nical.github.io/</id><updated>2019-12-26T00:00:00+01:00</updated><entry><title>A new tessellator</title><link href="https://nical.github.io/posts/new-tessellator.html" rel="alternate"></link><published>2019-12-26T00:00:00+01:00</published><updated>2019-12-26T00:00:00+01:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2019-12-26:/posts/new-tessellator.html</id><summary type="html">&lt;p&gt;This post is about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt;, a rust crate to tessellate arbitrary 2D shapes into triangle meshes that can be easily rendered on the GPU.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;About a year ago, in the &lt;a href="https://nical.github.io/posts/lyon-2018.html"&gt;lyon in 2018 post&lt;/a&gt; on this blog, I mentioned that I was working on a complete rewrite of lyon's central â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;This post is about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt;, a rust crate to tessellate arbitrary 2D shapes into triangle meshes that can be easily rendered on the GPU.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;About a year ago, in the &lt;a href="https://nical.github.io/posts/lyon-2018.html"&gt;lyon in 2018 post&lt;/a&gt; on this blog, I mentioned that I was working on a complete rewrite of lyon's central piece, the &lt;a href="https://docs.rs/lyon_tessellation/0.15.0/lyon_tessellation/struct.FillTessellator.html"&gt;fill tessellator&lt;/a&gt;. I have been working on this for quite a bit. The work-in-progress &lt;a href="https://github.com/nical/lyon/pull/334"&gt;pull request&lt;/a&gt; was created in February 2018. Almost two years in the making, this work made it in version &lt;a href="https://crates.io/crates/lyon/0.15.0"&gt;&lt;code&gt;0.15&lt;/code&gt;&lt;/a&gt;, the project's biggest release ever.&lt;/p&gt;
&lt;p&gt;It was a lot of work. Too much work. Fortunately, I am pretty happy about the result.&lt;/p&gt;
&lt;h1&gt;Motivation&lt;/h1&gt;
&lt;p&gt;So, why put so much effort in rewriting all of this?&lt;/p&gt;
&lt;h2&gt;Robustness&lt;/h2&gt;
&lt;p&gt;The fill tessellator was pretty robust, but not 100% bullet-proof. There's a built-in fuzzer in the test suite that could run for many hours before finding a shape that breaks the tessellator, but would always eventually stumble upon unrecoverable state and panic or return an error. The fuzzer wasn't the only entity to find issues. a few users reported some panics using the tessellator. Some of these reports were easy to address, some were very hard, and it almost always boiled down to precision loss introduced by arithmetic operations performed when detecting and handling self-intersecting geometry. The tessellator's algorithm had been built around a simplified mental model where arithmetic is precise, and key geometric properties could always be taken for granted. Long story short, there were some rare but very hard to fix bugs that required rethinking core parts of the algorithm.&lt;/p&gt;
&lt;p&gt;The new tessellator embraces the idea that no matter how hard we try to avoid it, some floating point precision issues will eventually cause some invalid states to appear. Instead of relying on this to be prevented the new algorithm is built around being able to detect and recover from these issues.&lt;/p&gt;
&lt;p&gt;This is done by splitting each iteration in two phases: the &lt;em&gt;scan phase&lt;/em&gt; has most of the interesting logic of the algorithm, but doesn't perform any mutation. Instead it records changes that will be applied int the &lt;em&gt;update phase&lt;/em&gt; which only performs the mutations.&lt;/p&gt;
&lt;p&gt;Errors can be detected during the scan phase. Sometimes these errors imply that some of the analysis performed during the scan is invalid (for example due to incorrect edge ordering), but it doesn't matter because the scan phase hasn't committed any mutation, so we can bail out of it, do our best to sanitize our initial state and run the iteration again.&lt;/p&gt;
&lt;p&gt;In overly-simplified Rust pseudo-code, the main loop looks somewhat like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tesselator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;algorithm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-&amp;gt; &lt;span class="nc"&gt;TessellationResult&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;iteration&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iterations&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// Invalid states can be detected during the &amp;quot;analysis&amp;quot; or &amp;quot;scan&amp;quot; phase.&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;updates&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scan_phase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iteration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nb"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;updates&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;updates&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nb"&gt;Err&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="c1"&gt;// Something is wrong, recover from it before trying again.&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recover_from_error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="c1"&gt;// Return an error if we fail the second time.&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scan_phase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iteration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// Internal mutations can only happen here.&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update_phase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;updates&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This doesn't sound like much but it is a major shift in how the algorithm is organized. This alone required a rewrite and it paid off.&lt;/p&gt;
&lt;p&gt;Another key aspect of the new design was avoiding to rely on prior events when information can be reconstructed locally. In other words try hard not to have invalid state accumulate and contaminate subsequent steps of the algorithm.&lt;/p&gt;
&lt;p&gt;I am sure that bugs will be found as it always goes with any new non-trivial piece of code. It'll be wise to take the claims I made about robustness with a grain of salt until the code has had a chance to be used in more places and pass the test of time. I have let the fuzzer run on 4 of cores of a beefy desktop for about 48 hours and it didn't find any panic. That's already a lot more robust than the previous tessellator, at least with the family of bugs that the fuzzer is good at finding. I am also confident that it will be much easier to fix upcoming issues with the new algorithm.&lt;/p&gt;
&lt;h2&gt;Getting rid of fixed-point numbers&lt;/h2&gt;
&lt;p&gt;In an effort to make reasoning about precision easier, the old tessellator had moved most (but not all) of its geometric calculations to a fixed point number representation. It helped at first but in the long run it turned out to be a mistake. A mistake that was impossible to come back from after months of adjusting thresholds and other knobs to paper over precision issues that still existed. Fixed-point numbers, while providing a somewhat consistent precision loss that I had an easier time wrapping my head around, still lost precision and didn't solve the root of the issue. They helped with the easy problems and got in the way of fixing the hardest ones.&lt;/p&gt;
&lt;p&gt;In addition, fixed point numbers came with two major drawbacks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The range of numbers that could represented inside the tessellator was greatly reduced in comparison with 32 bit floats. My initial feeling was that users wouldn't often need to work with coordinates larger than &lt;code&gt;32767.0&lt;/code&gt;, but that assumption proved to be wrong. While it was possible to work around the issue by scaling the path down and scaling the output mesh back up, it was far from a satisfying answer.&lt;/li&gt;
&lt;li&gt;The vertices generated by the tessellator were almost but not quite the same as the points of the input shapes, due to being converted to fixed-point and back to float.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The new tessellator internally works with 32 bit floating point numbers and the positions from the original path are now unmodified in the output.&lt;/p&gt;
&lt;h2&gt;Custom vertex attributes&lt;/h2&gt;
&lt;p&gt;In order to achieve certain effects it is often desirable to be able to associate extra attributes per-vertex attributes, for example color, texture coordinates, bone weights, etc.&lt;/p&gt;
&lt;p&gt;This has been lyon's most requested feature, but a tricky one to get right. On the surface it seems simple: give all path endpoints their own ID and present these IDs when building the vertices during tessellation. However the tessellator occasionally has to create new vertices that do not correspond to existing endpoints of the input path, for example when handling self-intersections or when flattening bÃ©zier curves.&lt;/p&gt;
&lt;p&gt;To address this, the tessellator keeps track for each vertex of all of the edges that it belongs to and where on these edges. This information can be cumbersome to consume, so a concept of interpolated attributes was built on top of it. The idea is that an array of floating point numbers can be associated to each of the input path's endpoints and passed to the geometry builder when generating vertices. When the source of a vertex is more complex than a single endpoint, the tessellator interpolates the values automatically.&lt;/p&gt;
&lt;p&gt;Find out more about this in the &lt;a href="https://docs.rs/lyon_tessellation/0.15.0/lyon_tessellation/struct.FillTessellator.html#vertex-sources"&gt;documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The same mechanism was also added to the stroke tessellator.&lt;/p&gt;
&lt;h2&gt;Fill rules&lt;/h2&gt;
&lt;p&gt;The old tessellator was pretty much written for the even-odd &lt;a href="https://www.w3.org/TR/SVG/painting.html#WindingRule"&gt;fill rule&lt;/a&gt; and adding more fill rules turned out to be difficult in hindsight. The new tessellator's algorithms was designed with this in mind and currently supports non-zero and even-odd. More fill rules can easily be added, but these two are the only ones in SVG standard.&lt;/p&gt;
&lt;p&gt;The image below shows the same path, filled with the even-odd (on the left) and non-zero (on the right) fill rules&lt;/p&gt;
&lt;p&gt;&lt;img alt="Fill rules" src="https://nical.github.io/images/lyon-evenodd-nonzero.png"&gt;&lt;/p&gt;
&lt;h2&gt;Other goodies&lt;/h2&gt;
&lt;p&gt;The new tessellator can dynamically chose to traverse the geometry vertically or horizontally. As a rule of thumb it is usually better for performance to do a vertical sweep for shapes that are taller than wide, and do an horizontal sweep for shapes that are wider than tall.&lt;/p&gt;
&lt;p&gt;The image below shows the triangles generated with vertical (on the left) and horizontal (on the right) traversals of the same path.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Vertical and horizontal traversals" src="https://nical.github.io/images/lyon-sweep-v-h.png"&gt;&lt;/p&gt;
&lt;p&gt;I spent a lot of time on the APIs related to building, storing and iterating over paths. This release has types to make working with simple &lt;a href="https://docs.rs/lyon_path/0.15.0/lyon_path/polygon/index.html"&gt;polygons&lt;/a&gt; nicer, as well as utilities to create &lt;a href="https://docs.rs/lyon_path/0.15.0/lyon_path/commands/index.html"&gt;custom path data structures&lt;/a&gt; which work with the tessellators.&lt;/p&gt;
&lt;h1&gt;What's the catch?&lt;/h1&gt;
&lt;p&gt;There are few caveats that I want to mention:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The old fill tessellator was able to provide normals at each vertex. The new tessellator, however, cannot do that. Removing normals allowed a great deal of much needed simplification. I don't think that I will add this feature back. The stroke tessellator still has vertex normals, though.&lt;/li&gt;
&lt;li&gt;The new tessellator is a bit slower than the old one. This is mostly due to not having spent a lot of time profiling and optimizing yet and I am pretty confident that most of the gap can be closed. The new implementation is still about 50% faster than libtess2 (which I consider to be the "industry standard") on the workloads I compared them against (mostly the Rust logo and GhostScript tiger), so it's still pretty decent.&lt;/li&gt;
&lt;li&gt;A lot of APIs have changed. If you've used lyon before it'll still be familiar but updating, while not difficult, is likely to take a bit of effort.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In previous blog posts I mentioned a plan to handle bÃ©zier curves directly in the tessellator in order to allow resolution-independent tessellations and handle curves on the GPU (using tessellation or fragment shaders). I had to scope the project down in order to finally get something to shippable and this feature didn't make it. It's possible that I'll revisit it some time in the future, but realistically it will take a long time before I get an ambitious feature such as this one to work, if I ever do.&lt;/p&gt;
&lt;h1&gt;What's next?&lt;/h1&gt;
&lt;p&gt;For a little while, bug fixes and polish, after which I am hoping to tag a symbolic &lt;code&gt;1.0&lt;/code&gt; release some time in 2020. I still have this project of improving the quality of the tessellated geometry (generating less thin triangles) that I would like to get back to, and There are a few algorithms I'd like to play with, like stroke-to-fill conversion and boolean operations.
I would also like to spend some time working &lt;em&gt;with&lt;/em&gt; lyon rather than only &lt;em&gt;on&lt;/em&gt; it, though I don't know yet what will come out of that.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;I am really happy and proud to finally release the new tessellator. It adds up to an enormous amount of work over the last two years, but I think that it was necessary to take the tessellator from pretty good to really robust and reliable. While uncompromising robustness was the main motivation behind this rewrite, a number of important features were also made possible.&lt;/p&gt;
&lt;p&gt;Although the rewrite wasn't well set up for external contributions, development didn't stop on the master branch! I would like to thank everyone who made contributions to lyon in 2019 and the years before. Also many thanks to everyone who reported bugs, for their time, patience and support.&lt;/p&gt;
&lt;p&gt;This blog does not have a comments section, discussion on &lt;a href="https://www.reddit.com/r/rust/comments/efz5jb/lyon_0150_a_new_tessellator/"&gt;reddit&lt;/a&gt;.&lt;/p&gt;</content><category term="lyon, rust"></category></entry><entry><title>Lyon in 2018</title><link href="https://nical.github.io/posts/lyon-2018.html" rel="alternate"></link><published>2019-02-17T00:00:00+01:00</published><updated>2019-02-17T00:00:00+01:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2019-02-17:/posts/lyon-2018.html</id><summary type="html">&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;About a year ago I published &lt;a href="https://nical.github.io/posts/lyon-intro.html"&gt;
"Introduction to lyon: 2D vector graphics rendering on the GPU in rust"
&lt;/a&gt; on this blog. Lyon was in version &lt;a href="https://docs.rs/lyon/0.8.8/lyon/"&gt;&lt;code&gt;0.8.8&lt;/code&gt;&lt;/a&gt; back then and I recently published &lt;a href="https://docs.rs/lyon/0.13.0/lyon/"&gt;&lt;code&gt;0.13.0&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In 2018 my activity on the project has varied depending on the time â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;About a year ago I published &lt;a href="https://nical.github.io/posts/lyon-intro.html"&gt;
"Introduction to lyon: 2D vector graphics rendering on the GPU in rust"
&lt;/a&gt; on this blog. Lyon was in version &lt;a href="https://docs.rs/lyon/0.8.8/lyon/"&gt;&lt;code&gt;0.8.8&lt;/code&gt;&lt;/a&gt; back then and I recently published &lt;a href="https://docs.rs/lyon/0.13.0/lyon/"&gt;&lt;code&gt;0.13.0&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In 2018 my activity on the project has varied depending on the time and energy I have had left after work and other activities. As it turns out, working on &lt;a href="http://mozillagfx.wordpress.com/"&gt;getting WebRender shipped in Firefox&lt;/a&gt; is at the same time amazing and very demanding, and what's left of my brain after a good day of work isn't always up to some of the ambitions I have planned for lyon. Fortunately I am not the only one who contributed to the project, and while progress was slow on the most ambitious plans, I did spend some time on smaller features and polish.&lt;/p&gt;
&lt;p&gt;I'll get to these big plans towards the end of this post. In the mean time let's look at some of the highlights of what changed in lyon in 2018.&lt;/p&gt;
&lt;h2&gt;lyon_geom&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_geom"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_geom"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_geom/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I want to start with an epic contribution from &lt;a href="https://github.com/kleintom"&gt;Tom Klein&lt;/a&gt;: The addition of a robust cubic bÃ©zier intersection algorithm using fat line clipping. You can read about this journey in the original &lt;a href="https://github.com/nical/lyon/pull/422"&gt;pull request&lt;/a&gt; and &lt;a href="https://github.com/nical/lyon/pull/427"&gt;followup improvements&lt;/a&gt;. Suffice to say, I'm impressed with the quality and rigor of the work Tom put in this feature.&lt;/p&gt;
&lt;p&gt;Tom also &lt;a href="https://github.com/nical/lyon/pull/419"&gt;added&lt;/a&gt; an elliptic arc to cubic bÃ©zier approximation (&lt;a href="https://docs.rs/lyon_geom/0.12.2/lyon_geom/arc/struct.Arc.html#method.for_each_cubic_bezier"&gt;doc link&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;There were other additions such as tight bounding rectangle calculation for elliptic arcs, improvements and fixes to the various curve approximation algorithms and a lot of API ergonomic improvements.&lt;/p&gt;
&lt;p&gt;This year has confirmed the trend that a number of people are using lyon_geom without the rest of lyon. The way the lyon crates are separated seems to have paid off in letting people who only want curve math tools get a minimal dependency.&lt;/p&gt;
&lt;h2&gt;lyon_tessellation&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_tessellation"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_tessellation"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_tessellation"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_tessellation/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To me, &lt;a href="https://docs.rs/lyon_tessellation/0.13.0/lyon_tessellation/struct.FillTessellator.html"&gt;the fill tessellator&lt;/a&gt; is the most important piece of the whole project. The majority of the changes to the fill tessellator were bug fixes, almost all of them related to dreadful numerical precision issues when paths have many self-intersections and in particular when a lot of these self-intersections are almost at the same position. This type of paths isn't representative of human generated content but the robustness of the tessellator is important to me and I want to keep improving it.&lt;/p&gt;
&lt;p&gt;As far as API changes are concerned, I added the possibility to chose the type of the generated indices of the vertex/index buffer pairs. Before that, indices were always &lt;code&gt;u16&lt;/code&gt; and some users ran into the limit when generating large amount of geometry with a single path or when tessellating too many paths in the same vertex and index buffer pair. The tessellator now internally works with &lt;code&gt;u32&lt;/code&gt; indices and the convenience &lt;a href="https://docs.rs/lyon_tessellation/0.13.0/lyon_tessellation/struct.BuffersBuilder.html"&gt;&lt;code&gt;BuffersBuilder&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://docs.rs/lyon_tessellation/0.13.0/lyon_tessellation/struct.VertexBuffers.html"&gt;&lt;code&gt;VertexBuffers&lt;/code&gt;&lt;/a&gt; output can be parametrized over the index type to provide the choice of &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt; or anything else that can be converted to a &lt;code&gt;VertexId&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In addition, the &lt;code&gt;GeometryBuilder&lt;/code&gt; trait and the tessellators are set up to properly handle running out of indices, interrupting the tessellation and returning an error instead of causing a panic as it previously did.&lt;/p&gt;
&lt;p&gt;This might sound like a detail but several people ran into it and the way the tessellator used to panic when running out of vertex ids was confusing so I am happy that this is now a thing of the past. My initial worry was that the added glue to forward and handle errors would regress performance (which it initially did by about 6%), but with a small amount profiling and tweaks I got the performance back within noise range of the original scores (on the benchmarks in the repository).&lt;/p&gt;
&lt;h2&gt;lyon_path&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_path"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_path"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_path"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_path/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This crate has received more attention than usual lately.&lt;/p&gt;
&lt;p&gt;The first thing people who update from earlier versions of lyon will notice is probably that &lt;code&gt;lyon::path::default::Path&lt;/code&gt; is now &lt;code&gt;lyon::path::Path&lt;/code&gt;. But there have been some more interesting developments than this namespace change.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/iterator/index.html"&gt;iterator APIs&lt;/a&gt; got a pretty major revamp. Previously the various flavors of path iterators would let you iterate over events such as &lt;code&gt;MoveTo(Point)&lt;/code&gt;, &lt;code&gt;Close&lt;/code&gt;, &lt;code&gt;LineTo(Point)&lt;/code&gt; and equivalent curve segments types, in a postscript fashion similar to how the paths are created, in which we don't repeat the start of the event since we already provided it as the end of the previous one.
This was simple to implement since it maps to how the path is stored, but pretty much every consumer of the API would have to keep track of both the previous end of segment and the starting position of the curve to do any meaningful work with the segments of the path.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;PathEvent&lt;/code&gt; enum looked like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;pub&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="nc"&gt;PathEvent&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;MoveTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;LineTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;QuadraticTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// control point, to&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// etc.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And now looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;pub&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="nc"&gt;PathEvent&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;MoveTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LineSegment&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LineSegment&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Quadratic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QuadraticBezierSegment&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// etc.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In other words, I shifted the burden of tracking this information from the user to &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/struct.Iter.html"&gt;the iterator&lt;/a&gt; implementation by making path events contain the actual segments and by providing the closing segment in &lt;code&gt;PathEvent::Close(LineSegment&amp;lt;f32&amp;gt;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I also removed &lt;code&gt;PathSegment::Arc&lt;/code&gt; (elliptic arcs automatically get approximated with a sequence of cubic bÃ©zier curves) and simplified the &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/iterator/trait.PathIterator.html"&gt;&lt;code&gt;PathIterator&lt;/code&gt; trait&lt;/a&gt; which is now a simple extension trait implemented for all &lt;code&gt;Iterator&amp;lt;Item = PathEvent&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There is also a new &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/struct.Cursor.html"&gt;&lt;code&gt;Cursor&lt;/code&gt; API&lt;/a&gt; which makes it possible to refer to specific positions within a path and work with portions of paths instead of always iterating over the entire path from the beginning.&lt;/p&gt;
&lt;p&gt;A &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/iterator/trait.FlattenedIterator.html#method.length"&gt;helper to approximate the length of a path&lt;/a&gt; using adaptive curve flattening was added, although Raph Levien wrote about &lt;a href="https://raphlinus.github.io/curves/2018/12/28/bezier-arclength.html"&gt;a faster way to evaluate the length of bÃ©zier curve segments&lt;/a&gt; which he implemented in in the &lt;a href="http://github.com/linebender/kurbo"&gt;kurbo&lt;/a&gt; crate. Perhaps some of this good stuff will make its way into lyon as well eventually.&lt;/p&gt;
&lt;p&gt;In the long term I want to experiment with more changes to the path data structure, for example making it generic over the vertex type to allow &lt;code&gt;f64&lt;/code&gt; coordinates and potentially arbitrary per-point attributes (for example one could want to store colors, line width, etc.).&lt;/p&gt;
&lt;h2&gt;lyon_algorithms&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_algorithms"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_algorithms"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_algorithms"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_algorithms/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A new crate was introduced this year! &lt;a href="https://docs.rs/lyon_algorithms/"&gt;lyon_algorithms&lt;/a&gt; contains a number of path related transformations and algorithms such as &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/hatching/index.html"&gt;generating hatching and dotting patterns&lt;/a&gt;, &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/splitter/struct.Splitter.html"&gt;splitting paths&lt;/a&gt;, &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/aabb/index.html"&gt;computing bounding boxes&lt;/a&gt;, &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/raycast/fn.raycast_path.html"&gt;ray casting&lt;/a&gt; and &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/walk/index.html"&gt;walking along a path at constant speed&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I wrote most of these algorithms for fun. I don't think I will pursue the same robustness goals as the fill tessellator there (path splitting has some very difficult edge cases when several segments overlap exactly for example), but I think that they are good enough to be useful to a lot of people.&lt;/p&gt;
&lt;p&gt;I'd love to add more algorithms there, like boolean operations, path simplification, path smoothing, path interpolation, and so on.&lt;/p&gt;
&lt;p&gt;I have used these algorithms to generate procedural shapes and print them with my &lt;a href="https://www.axidraw.com/"&gt;axidraw&lt;/a&gt; and it's a ton of fun. Hopefully, some people in the plotting community will find them useful.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Hatching example" src="https://nical.github.io/images/hatching-screenshot.png"&gt;&lt;/p&gt;
&lt;h2&gt;Work in progress&lt;/h2&gt;
&lt;p&gt;I mentioned at the beginning of the post that I have been making slow progress on two fronts:&lt;/p&gt;
&lt;h3&gt;A new fill tessellator&lt;/h3&gt;
&lt;p&gt;This work is happening in the &lt;a href="https://github.com/nical/lyon/pull/334"&gt;new-tess branch&lt;/a&gt;. The main motivations for this are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Better robustness against numerical precision issues. In broad strokes, the idea is to organize the algorithm so that it can detect and recover from precision bugs that break the invariants of the algorithm. It is a little hard to describe, but in a nutshell the approach is to accept that some arithmetic will produce results that break the invariant of the algorithm and split iterations of the main loop into an analysis phase where we get a chance to detect the error, backtrack one step and recover from it, and a mutation phase. In contrast the current tessellator interleaves mutations of its internal state with analysis of the geometry in a way that makes it hard to interrupt the iteration and recover if a bad state is detected.&lt;/li&gt;
&lt;li&gt;Support arbitrary vertex attributes. Today it is hard to associate external data such as colors or bone weights for animation to each vertex and use it in the output of the tessellator.&lt;/li&gt;
&lt;li&gt;Move away from fixed point numbers which the current tessellator uses internally. I originally thought that they would be the key to taming precision issues, but it didn't work out that well, and introduced new issues like a limited range of numbers that the tessellator can represent internally.&lt;/li&gt;
&lt;li&gt;Support for more fill rules (even-odd is the only currently supported fill rule in the current tessellator).&lt;/li&gt;
&lt;li&gt;Handling quadratic bÃ©zier curves directly in the tessellator. The tessellator would be able to either flatten curves on the fly during tessellation, or produce a mesh in which the curves could be evaluated in a fragment shader or tessellation shader. This goal longer term than the others, though.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So far the new tessellator is able to tessellate all of the non-self intersecting curves I have thrown at it (good thing lyon has a pretty large test suite), but doesn't detect intersections yet, and that's on purpose: ignoring intersections is a great way to mess the internal state of the algorithm up and see if it can recover and continue from there. I'll implement detecting and handling intersections eventually of course.
I have put no effort in performance yet (will get to that when the new tessellator is close to being usable), it doesn't handle curves and I haven't settled on a way to model the API to support arbitrary vertex attributes when vertices are added during tessellation (again because of self-intersections).&lt;/p&gt;
&lt;h3&gt;Higher quality monotone tessellation&lt;/h3&gt;
&lt;p&gt;By "higher quality", I mean reducing the amount of thin triangles that are generated by the algorithm. Long thin triangles have undesirable properties. For example they tend to produce precision issues when used in certain algorithms like physics simulation, and be &lt;a href="https://www.g-truc.net/post-0662.html"&gt;slower to render on the GPU&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The monotone polygon decomposition approach used in lyon has a tendency to produce long horizontal triangles in some cases. I have a prototype that improves upon this but fails in some cases. To be continued.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Thin triangles illustration" src="https://nical.github.io/images/rustfest/adv-monotone.svg"&gt;&lt;/p&gt;
&lt;h2&gt;Wrapping up&lt;/h2&gt;
&lt;p&gt;2018 Was a good year for lyon. In this post I put forth Tom Klein's contribution, but other people also helped get the project where it is today. If your name is on &lt;a href="https://github.com/nical/lyon/wiki/Contributors"&gt;the contributor list&lt;/a&gt;, then you are awesome and I thank you.&lt;/p&gt;
&lt;p&gt;Hopefully 2019 will be the year where the new tessellator matures and replaces the current one and maybe the start of a small vector graphics rendering crate built on top of gfx-hal.&lt;/p&gt;</content><category term="lyon, rust"></category></entry><entry><title>RustFest Paris - Part 2 - Path rendering challenges</title><link href="https://nical.github.io/posts/rustfest-paris-02.html" rel="alternate"></link><published>2018-06-19T00:00:00+02:00</published><updated>2018-06-19T00:00:00+02:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2018-06-19:/posts/rustfest-paris-02.html</id><summary type="html">&lt;p&gt;This is the second part of a series about the talk I gave at &lt;a href="https://paris.rustfest.eu/"&gt;RustFest Paris&lt;/a&gt; about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt;, a crate that helps you render vector graphics on the GPU in Rust.&lt;/p&gt;
&lt;p&gt;The recordings can be found &lt;a href="https://app.media.ccc.de/v/rustfest18-7-vector_graphics_rendering_on_the_gpu_in_rust_with_lyon"&gt;here&lt;/a&gt; or on &lt;a href="https://www.youtube.com/watch?v=2Ng5kpDirDI&amp;amp;list=PL85XCvVPmGQgdqz9kz6qH3SI_hp7Zb4s1&amp;amp;index=7"&gt;YouTube&lt;/a&gt; if you prefer.&lt;/p&gt;
&lt;p&gt;Previous episode:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="rustfest-paris-01.html"&gt;Part 1 - Intro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;The problem â€¦&lt;/h1&gt;</summary><content type="html">&lt;p&gt;This is the second part of a series about the talk I gave at &lt;a href="https://paris.rustfest.eu/"&gt;RustFest Paris&lt;/a&gt; about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt;, a crate that helps you render vector graphics on the GPU in Rust.&lt;/p&gt;
&lt;p&gt;The recordings can be found &lt;a href="https://app.media.ccc.de/v/rustfest18-7-vector_graphics_rendering_on_the_gpu_in_rust_with_lyon"&gt;here&lt;/a&gt; or on &lt;a href="https://www.youtube.com/watch?v=2Ng5kpDirDI&amp;amp;list=PL85XCvVPmGQgdqz9kz6qH3SI_hp7Zb4s1&amp;amp;index=7"&gt;YouTube&lt;/a&gt; if you prefer.&lt;/p&gt;
&lt;p&gt;Previous episode:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="rustfest-paris-01.html"&gt;Part 1 - Intro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;The problem&lt;/h1&gt;
&lt;p&gt;Screens tend to have a lot of pixels these days.&lt;/p&gt;
&lt;p&gt;&lt;img alt="screens" src="https://nical.github.io/images/rustfest/screen.svg"&gt;&lt;/p&gt;
&lt;p&gt;To the point that when rendering interesting vector graphics (or rendering anything, really) at a high resolution, the per-pixel work adds up and becomes a real challenge for the CPU to process sequentially. Our goal here is to render complex vector graphics at interactive frame rates (This typically means a 16ms budget per frame) and we'd obviously like to have some processing power left to do other things.&lt;/p&gt;
&lt;h1&gt;Filling paths on the CPU&lt;/h1&gt;
&lt;p&gt;I am going to use the term "rasterization" and "rasterizer" quite a bit in this post. &lt;a href="https://en.wikipedia.org/wiki/Rasterisation"&gt;Rasterization&lt;/a&gt;, in a nutshell, is the action of turning vector graphics into raster graphics. In other words it's taking vector graphics and rendering them into pixels. I'll focus on filling paths which is probably the most common primitive, but it's not the only thing vector graphics are made of.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What's the deal with GPUs, anyway? I have a beefy CPU, isn't that enough?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Because images are usually laid out in memory row by row in a contiguous buffer, it's ideal to fill shapes from top to bottom, row after row to maximize cache locality of memory accesses and help the CPU's prefetcher.
So it comes without surprise that most path filling implementations use &lt;a href="https://en.wikipedia.org/wiki/Sweep_line_algorithm"&gt;sweep-line algorithms&lt;/a&gt;. The general idea is to start with a list of the path's edges sorted from top to bottom. Imagine an imaginary line (the sweep-line) that traverses the output image a row of pixels at a time. We maintain another list, this one containing the edges that intersect the current row, sorted from left to right (let's call them active edges). During the traversal we use the first sorted list to know which edges to add to the active edge list and when. For each row we go through the active edge list to figure out where to start and stop filling pixels, as well as what to do with pixels that are partially covered.&lt;/p&gt;
&lt;p&gt;&lt;img alt="sweep line" src="https://nical.github.io/images/rustfest/sweepline.gif"&gt;&lt;/p&gt;
&lt;p&gt;There are variations around this algorithm. For example some implementations run the algorithm in a single pass while others will first generate a data structure that represents the spans of pixels to fill and then fill the pixels in a second pass.&lt;/p&gt;
&lt;p&gt;Sweep-lines are very useful when dealing with a lot of different geometry problems (2D and 3D alike) I think that I'll come back to what I like so much about them in another post (maybe in part 3).&lt;/p&gt;
&lt;p&gt;For now if you are interested in knowing more about this stuff I recommend having a look at &lt;a href="https://searchfox.org/mozilla-central/rev/3737701cfab93ccea04c0e9cab211ad10f931d87/gfx/skia/skia/src/core/SkScan_Path.cpp#106"&gt;Skia's scanline rasterization code&lt;/a&gt;, or &lt;a href="http://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/raster/ftraster.c?id=af585ad4fec965fa85f5d61c759f3bc940936de4#n2652"&gt;Freetype's&lt;/a&gt;. The coding style is different but the overall principle is the same. Oh and since this blog post is written in the context of rustfest, you can check &lt;a href="https://github.com/redox-os/rusttype/blob/master/src/rasterizer.rs"&gt;rusttype's rasterizer&lt;/a&gt; out too, it's implemented in rust.&lt;/p&gt;
&lt;p&gt;&lt;img alt="scanline fill" src="https://nical.github.io/images/rustfest/raster.svg"&gt;&lt;/p&gt;
&lt;p&gt;There is another approach worth mentioning implemented in &lt;a href="https://medium.com/@raphlinus/inside-the-fastest-font-renderer-in-the-world-75ae5270c445"&gt;font.rs&lt;/a&gt;, which involves rendering information about the outline of the shape in an accumulation buffer and using that as input to fill the shape in a single tightly optimized loop over the destination image. Notable about this approach is the simplicity of the main filling loop. It runs the same logic on all pixels inside and outside of the shape with very few branches which is very efficient on modern CPUs, at the expense of going over pixels that are outside the shape. When rendering very small images this trade-off works wonderfully. When rendering at very large resolutions, having a sparse representation to avoid touching pixels outside of the shape begins paying off.&lt;/p&gt;
&lt;p&gt;This is a good segue into an important point: There is no optimal one-size-fits-all (or should I say, one-fits-all-sizes!) solution.
When filling a small amount of pixels, a lot of time is typically spent computing the anti-aliasing along the edges, while paths that cover lots of pixel tend to put more pressure on memory bandwidth filling the interior.&lt;/p&gt;
&lt;p&gt;With lyon I focused on large paths covering many pixels, and I wouldn't advise using lyon to render very small text. In another post in this series I will talk a bit about &lt;a href="https://github.com/pcwalton/pathfinder"&gt;pathfinder&lt;/a&gt; which implements two algorithms: one for small resolutions (typically text), and one for larger paths.
I think that there is no way around having dedicated implementations if you want to cover both use cases optimally.&lt;/p&gt;
&lt;h1&gt;Overdraw&lt;/h1&gt;
&lt;p&gt;We saw how to figure out which pixels are inside a shape and fill them. From there to a drawing containing hundreds of paths the process is usually to render these paths individually from back to front, so that front-most elements don't get overwritten by the ones behind them.
Simple enough, however this means that for drawings that are built upon many shapes stacked on top of one another like the famous GhostScript tiger, pixels will typically get written to many times. It's quite a shame, because it means that hidden parts add to the rendering cost just as much as the rest even though they do not contribute to the final image.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ghostscript tiger overdraw" src="https://nical.github.io/images/rustfest/tiger-overdraw.svg"&gt;&lt;/p&gt;
&lt;p&gt;The image above gives an idea of the overdraw for the GhostScript tiger. The lighter a pixel is, the more times it is written to with a traditional back to front rendering algorithm.&lt;/p&gt;
&lt;p&gt;Where overdraw really hurts is usually memory bandwidth. Unfortunately hammering memory tends to make every thing else slower as well. The other threads end up sitting around waiting for memory which limits parallelism, and after the algorithm is done running, other code will typically run into cold caches. It is very hard to avoid this cost in the context of rasterizing 2D graphics on the CPU (in the best case scenario we have to touch every pixel at least once which is already quite a lot).
I have to mention a very cool technique that helps a lot here: the "full-scene rasterizer" approach which consists in having a single sweep-line that renders all paths at once and therefore can touch pixels only once. The rumor has it that the Flash runtime has such an implementation. See also &lt;a href="https://github.com/jrmuizel/full-scene-rasterizer/"&gt;Jeff Muizelaar's full-scene rasterizer&lt;/a&gt; which is open-source. This is however quite hard to implement.&lt;/p&gt;
&lt;h1&gt;What about games?&lt;/h1&gt;
&lt;p&gt;So how do games manage to render so much complex content at interactive frame rates?
For a large part the answer is that games almost always use the GPU for graphics tasks. GPU's have been historically designed and optimized specifically for the needs of the games industry. It would be great if we could leverage these hardware level optimizations when working with 2D content.&lt;/p&gt;
&lt;p&gt;Now saying that something's going to be fast because it uses the GPU is certainly not enough. It is very easy to do slow things with a GPU, especially when trying to port CPU code over. Rather than try to adapt a CPU algorithm to the GPU let's try to reformulate our 2D rendering problem in a way that corresponds to the type of inputs GPUs typically get.&lt;/p&gt;
&lt;p&gt;&lt;img alt="3D rendering" src="https://nical.github.io/images/rustfest/3d.svg"&gt;&lt;/p&gt;
&lt;p&gt;The vast majority of 3D content in interactive applications is made of triangle meshes. The GPU has dedicated hardware for dealing with triangles which makes this primitive very appealing for us. Perhaps if we turn vector shapes into flat triangle meshes (conceptually like a 3D mesh with z = 0) we can get somewhere, and that's the direction I took with lyon.
There are other approaches to rendering vector graphics on the GPU. As I mentioned earlier I don't believe in a one-size-fits-all solution, however I am pretty confident about geometry-based approaches (leveraging the triangle rasterizer) for the use cases I care most about.&lt;/p&gt;
&lt;p&gt;Another interesting feature of the GPU's rasterization pipeline is the depth buffer which contains the depth of each pixel in screen-space. This allows games to render opaque objects in any order and reject pixels that are further behind if something closer to the viewer has already been rendered at that location.
This is a convenient trick for correctness but it is also a great tool to reduce memory bandwidth, since by rendering opaque objects front to back, one can minimize the amount of time pixels are written to and greatly reduce memory bandwidth (remember that memory bandwidth was a big issue for CPU rasterization). Transparent objects are then rendered back to front since painting order actually matters for them.&lt;/p&gt;
&lt;p&gt;&lt;img alt="z-buffer" src="https://nical.github.io/images/rustfest/zbuffer.png"&gt;&lt;/p&gt;
&lt;p&gt;The illustration above was not in the rustfest presentation but perhaps it will help understanding what I am getting at with the depth buffer savings. This is a trick we use in WebRender that consists in rendering opaque shapes in front to back order with the depth buffer enabled to avoid touching pixels many times.
The memory bandwidth savings are actually greater than they seem thanks to smart optimizations implemented in the hardware that allow it to quickly discard entire blocks of pixels at a time before computing their color and writing them to memory.&lt;/p&gt;
&lt;h1&gt;Rendering 2D graphics like a 3D game&lt;/h1&gt;
&lt;p&gt;Lyon in it's current state is not a 2D rendering engine. It is mainly a way to take vector graphics primitives such as paths, and turn them into triangle meshes in a format that is straightforward to render on the GPU (but lyon doesn't implement the GPU bits at this point). The process of turning paths into triangle meshes is called &lt;em&gt;tessellation&lt;/em&gt; (some also use the word &lt;em&gt;triangulation&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img alt="Lyon logo as a triangle mesh" src="https://nical.github.io/images/lyon-logo-tessellated.png"&gt;&lt;/p&gt;
&lt;p&gt;If there is a beautiful thing about leveraging the GPU's triangle rasterization pipeline, is that since rendering becomes similar to a video game, we can use the graphics hardware exactly the way it has been meant to be used and benefit from many years of rendering tricks and optimizations from the games industry.&lt;/p&gt;
&lt;p&gt;The front to back depth buffer trick I mentioned earlier is not actually something implemented in lyon. It is just a very common optimization in 3D game engines which applies naturally when rendering paths tessellated using lyon. It is also a technique we use in &lt;a href="https://github.com/servo/webrender"&gt;webrender&lt;/a&gt; to great effects, and (spoiler alert) it's also &lt;a href="https://github.com/pcwalton/pathfinder"&gt;pathfinder&lt;/a&gt;'s most significant optimization for large paths.&lt;/p&gt;
&lt;p&gt;This is only one of the many tricks that we can learn from games. Game developers have come up with interesting approaches to anti-aliasing, various graphics effects, animation, handling thousands of individual objects and many more challenges which we can apply to our own needs.&lt;/p&gt;
&lt;h1&gt;Ã€ suivre...&lt;/h1&gt;
&lt;p&gt;This was part two. We had a superficial look at 2D rendering on the CPU and I argued that there are some benefits to picking a games-like approach to rendering on the GPU.
In the next post we will delve into lyon's tessellation algorithm itself.&lt;/p&gt;</content><category term="lyon, rust"></category></entry><entry><title>RustFest Paris - Part 1 - Intro</title><link href="https://nical.github.io/posts/rustfest-paris-01.html" rel="alternate"></link><published>2018-06-18T00:00:00+02:00</published><updated>2018-06-18T00:00:00+02:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2018-06-18:/posts/rustfest-paris-01.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;RustFest organizer: "Are you ready?"&lt;/p&gt;
&lt;p&gt;Me: "Almost."&lt;/p&gt;
&lt;p&gt;(reinstalling Xorg on my laptop 20 minutes before the talk because the window manager would not start)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I gave a talk about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt; at &lt;a href="https://paris.rustfest.eu/"&gt;RustFest Paris&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The recordings are already online, so you can watch it &lt;a href="https://app.media.ccc.de/v/rustfest18-7-vector_graphics_rendering_on_the_gpu_in_rust_with_lyon"&gt;here&lt;/a&gt; or on &lt;a href="https://www.youtube.com/watch?v=2Ng5kpDirDI&amp;amp;list=PL85XCvVPmGQgdqz9kz6qH3SI_hp7Zb4s1&amp;amp;index=7"&gt;YouTube&lt;/a&gt; if you prefer â€¦&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;RustFest organizer: "Are you ready?"&lt;/p&gt;
&lt;p&gt;Me: "Almost."&lt;/p&gt;
&lt;p&gt;(reinstalling Xorg on my laptop 20 minutes before the talk because the window manager would not start)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I gave a talk about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt; at &lt;a href="https://paris.rustfest.eu/"&gt;RustFest Paris&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The recordings are already online, so you can watch it &lt;a href="https://app.media.ccc.de/v/rustfest18-7-vector_graphics_rendering_on_the_gpu_in_rust_with_lyon"&gt;here&lt;/a&gt; or on &lt;a href="https://www.youtube.com/watch?v=2Ng5kpDirDI&amp;amp;list=PL85XCvVPmGQgdqz9kz6qH3SI_hp7Zb4s1&amp;amp;index=7"&gt;YouTube&lt;/a&gt; if you prefer.&lt;/p&gt;
&lt;p&gt;&lt;img alt="lets talk about vector graphics svg" src="https://nical.github.io/images/rustfest/intro.svg"&gt;&lt;/p&gt;
&lt;p&gt;Even though I didn't feel super good about the flow of my speech this time around, I think that the talk was well received and the last minute "let's fix my window manager" episode didn't turn into a disaster.&lt;/p&gt;
&lt;p&gt;It motivated me to write a series of short blog posts about the content of the talk, and explain in more details the information which I was delivering in a hurry in the hope that I wouldn't blow up the talk's allocated time slice. Most of the images in this series of posts are slides from the presentation (made in SVG with Inkscape), but there will be additional content too.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="rustfest-paris-01.html"&gt;Part 1 - Intro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="rustfest-paris-02.html"&gt;Part 2 - Path rendering challenges&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 3 - Lyon's path tessellation algorithm&lt;/li&gt;
&lt;li&gt;Part 4 - Other GPU rendering approaches.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post is the introduction of the talk, wherein I introduce vector graphics and try to get the audience somewhat excited about it. Things will get technical in the follow-up posts.&lt;/p&gt;
&lt;h1&gt;RustFest&lt;/h1&gt;
&lt;p&gt;Before I delve into the talk, I'd like to thank the organizers for their great work on RustFest. I can only begin to imagine how stressful and exhausting it can be to organize such an event and I believe it paid off. I had a great time and I believe the other attendees did as well.&lt;/p&gt;
&lt;h1&gt;Raster graphics and vector graphics&lt;/h1&gt;
&lt;p&gt;Before I delve into lyon, let's get the terminology straight. Raster graphics is what typically comes to mind when thinking about images: a uniform grid of pixels where the color of each pixel is specified independently. Working with uniform grids has a lot of nice properties, for example having random-access in the content of the image to sample the color at a particular point, and being able to perform complex operations that sort of rely on random access like convolution filters.&lt;/p&gt;
&lt;p&gt;On the other hand raster images force authors to think about the resolution at which content is produced versus resolution at which it is presented (the output resolution of a screen for example), and they don't always happen to line up perfectly. So what happens when a 800x450 pixels image has to fill a 2560x1440 pixels screen? In most cases the image will look either blurrier or pixelated. At high resolutions, raster images occupy a lot of space. Image compression formats (png, jpeg and more modern successors) do their best to mitigate that in clever ways but size remains a limiting factor when dealing with large amounts of high resolution raster images, be it in terms of disk pass, or network bandwidth.&lt;/p&gt;
&lt;p&gt;&lt;img alt="slide raster vs vector" src="https://nical.github.io/images/rustfest/rstr-vctr.svg"&gt;&lt;/p&gt;
&lt;p&gt;Fortunately, specifying 2D content pixel by pixel is not the only choice we have at our disposal. In a lot of cases we can author and distribute not the resulting image but the steps to produce it. In very broad terms this is what I refer to when talking about vector graphics.&lt;/p&gt;
&lt;p&gt;Think of the SVG format which can be produced with Inkscape or illustrator. With vector graphics instead of specifying a grid of pixel colors you deal in terms of squares, circles, shapes, polygons, bÃ©zier curves, which you can fill and stroke with different types of patterns such as solid colors and gradients. Of course these shapes will eventually get rasterized into a raster image since that's what your screen understands, but the description of vector graphics allows to a great extent to be resolution-independent and happens to be very compact (since specifying a red square requires a small amount of data no matter how many pixels this square will eventually cover).&lt;/p&gt;
&lt;p&gt;Beyond SVG, I consider HTML/CSS to be a vector graphics format, since it is built around the idea of describing how to display 2D content rather than specifying each pixel individually.&lt;/p&gt;
&lt;p&gt;The little shape in the image above doesn't look like much but add many more and you can end up with complex drawings like the famous GhostScript tiger which inevitably appears in any presentation on the topic of vector graphics.&lt;/p&gt;
&lt;p&gt;&lt;img alt="tiger" src="https://nical.github.io/images/rustfest/tiger.svg"&gt;&lt;/p&gt;
&lt;h1&gt;Vector graphics everywhere&lt;/h1&gt;
&lt;p&gt;Today graphical applications all make use of vector graphics. Fonts are almost always described with vector formats, user interfaces, just like web pages need to be described in a way that adapts to various layouts and resolutions, a problem that vector graphics lends itself to addressing naturally.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ui slide" src="https://nical.github.io/images/rustfest/ui.svg"&gt;&lt;/p&gt;
&lt;p&gt;Using a vector format to describe maps avoids spending a lot of network bandwidth on all of these pixels and lets you zoom in and out of a map without seeing a blurry mess (unless the application is unable to render the map at interactive frame rate and choses to show you a scaled version of the previous frame while it renders the new one).&lt;/p&gt;
&lt;p&gt;&lt;img alt="maps" src="https://nical.github.io/images/rustfest/map.svg"&gt;&lt;/p&gt;
&lt;p&gt;Using vector graphics in games can be useful as well. Today, 3D and 2D games come with gigabytes of assets, a huge part of it being fairly high resolution textures. This can be very inconvenient when attempting to distribute games over the network or even just fitting the game alongside the other installed apps in a relatively small drive.
Some games could also take advantage of the resolution-independence to present content at different scales for gameplay purposes or to enhance the story telling.&lt;/p&gt;
&lt;p&gt;&lt;img alt="rpg" src="https://nical.github.io/images/rustfest/rpg.svg"&gt;&lt;/p&gt;
&lt;h1&gt;Vector graphics at 60 frames per seconds&lt;/h1&gt;
&lt;p&gt;Turns out that rendering a screen-full of complex vector graphics at an interactive frame rate is challenging. Whether it is on a laptop or a phone, Screens tend to have a &lt;em&gt;lot&lt;/em&gt; of pixels. Filling this many pixels with interesting content means a fair amount of arithmetic, and involves a lot of memory accesses. To make things worse, the drawing model for 2D content is typically based on the &lt;a href="https://en.wikipedia.org/wiki/Painter%27s_algorithm"&gt;painter's algorithm&lt;/a&gt; which consists in drawing back to front, and this content is usually built upon many overlapping layers. Take a closer look at the tiger above to see what I mean. pixels tend to be written to many times (this is called overdraw), which amplifies the cost of rendering at a high resolution.&lt;/p&gt;
&lt;p&gt;&lt;img alt="screens" src="https://nical.github.io/images/rustfest/screen.svg"&gt;&lt;/p&gt;
&lt;p&gt;As a result of that a lot of applications tend to consider rendering complex vector graphics to be too expensive for high frequency updates and either bake 2D content into textures before releasing the product (a lot of games do that) or architect their rendering tech around hiding this cost, for example by rendering to intermediate surfaces at a low frequency while these surfaces are composited to the screen at a higher frequency, which allows some types of animations stay at a solid 60fps (web browsers in particular do this).&lt;/p&gt;
&lt;h1&gt;Ã€ suivre...&lt;/h1&gt;
&lt;p&gt;That's it for part one. In the next post we'll look at how games approach the problem of redrawing the entire screen with complex content at interactive frame rates. We'll see that we can take advantage of these solutions and apply them to rendering 2D vector graphics as well.&lt;/p&gt;</content><category term="lyon, rust"></category></entry><entry><title>Introduction to lyon: 2D vector graphics rendering on the GPU in rust</title><link href="https://nical.github.io/posts/lyon-intro.html" rel="alternate"></link><published>2018-01-22T00:00:00+01:00</published><updated>2018-01-22T00:00:00+01:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2018-01-22:/posts/lyon-intro.html</id><summary type="html">&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nical/lyon"&gt;Lyon&lt;/a&gt; is a side-project that I have been working on for quite a while. The goal is to play with rendering 2D vector graphics on the GPU, and it's been a lot of fun so far. I haven't talked a lot about it online (except for a couple of reddit â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nical/lyon"&gt;Lyon&lt;/a&gt; is a side-project that I have been working on for quite a while. The goal is to play with rendering 2D vector graphics on the GPU, and it's been a lot of fun so far. I haven't talked a lot about it online (except for a couple of reddit threads a year or two ago) so I figured it would be a good topic to get this blog started.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The logo" src="https://nical.github.io/images/lyon-logo.svg"&gt;&lt;/p&gt;
&lt;p&gt;In this post I'll talk very briefly about tessellators (lyon's biggest feature) and show a few code snippets to illustrate some of the things you can do with lyon today.&lt;/p&gt;
&lt;h2&gt;Tessellation&lt;/h2&gt;
&lt;p&gt;Path tessellation (or triangulation), in a nutshell, is taking a path (for example a &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Path2D/Path2D"&gt;canvas&lt;/a&gt; or &lt;a href="https://www.w3.org/TR/SVG/paths.html#PathData"&gt;SVG&lt;/a&gt; path) and approximating it with a set of triangles (like the way we usually represent 3d models but in 2d). While the output of the tessellator is customizable, lyon is pretty much designed for generating vertex and index buffers, which anyone working with low level graphics APIs should be familiar with. As a result we obtain geometry in a format that is very easy to work with on the GPU using the same techniques used for 3D graphics.&lt;/p&gt;
&lt;p&gt;&lt;img alt="tessellated shape" src="https://nical.github.io/images/lyon-logo-tessellated.png"&gt;&lt;/p&gt;
&lt;h2&gt;Monotone decomposition&lt;/h2&gt;
&lt;p&gt;So how do we go about tessellating a path? The three most common algorithms are &lt;a href="https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf"&gt;ear-clipping&lt;/a&gt;, &lt;a href="http://www0.cs.ucl.ac.uk/staff/m.slater/Teaching/CG/1997-98/Solutions/Trap/"&gt;trapezoidal decomposition&lt;/a&gt; and monotone decomposition. In lyon I went for the latter.&lt;/p&gt;
&lt;p&gt;Traditionally this algorithm is performed in three passes over the geometry:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first step is to partition the shape in non-self-intersecting shapes (usually using the &lt;a href="https://en.wikipedia.org/wiki/Bentley%E2%80%93Ottmann_algorithm"&gt;Bentley-Ottmann algorithm&lt;/a&gt;),&lt;/li&gt;
&lt;li&gt;then partition these into y-monotone shapes,&lt;/li&gt;
&lt;li&gt;and finally tessellate these y-monotone shapes into triangles.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I want to come back to this in greater details in another post, but I'll just mention here that lyon's fill tessellator is a bit different from the typical implementation of monotone tessellation in the way it represents paths, and runs the steps above in single pass instead of three. Diverging from the traditional implementations seems to pay off since some &lt;a href="https://github.com/nical/lyon/blob/53b6eb48f6c01e1ff8cf6c0ce4010c9019d63e39/bench/tess/src/main.rs#L154"&gt;early measurements&lt;/a&gt; show lyon to be a bit more than twice as fast as &lt;a href="https://github.com/memononen/libtess2"&gt;libtess2&lt;/a&gt;. Take this with a grain of salt, I do need to measure a much wider range of test cases before I can boast about anything, but it's encouraging and there are still a lot of low hanging fruits on the performance side of things.&lt;/p&gt;
&lt;h2&gt;Let's look at some code&lt;/h2&gt;
&lt;p&gt;The easiest way to show off some of what lyon can do for you is to look at some code snippets:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;crate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;math&lt;/span&gt;::&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;path&lt;/span&gt;::&lt;span class="n"&gt;default&lt;/span&gt;::&lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;::&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;tessellation&lt;/span&gt;::&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Build a Path.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;move_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quadratic_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cubic_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Let&amp;#39;s use our own custom vertex type instead of the default one.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cp"&gt;#[derive(Copy, Clone, Debug)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;MyVertex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;: &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;normal&lt;/span&gt;: &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Will contain the result of the tessellation.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;VertexBuffers&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tessellator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FillTessellator&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// Compute the tessellation.&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;tessellator&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tessellate_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path_iter&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;FillOptions&lt;/span&gt;::&lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BuffersBuilder&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;: &lt;span class="nc"&gt;FillVertex&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;MyVertex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;: &lt;span class="nc"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_array&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="n"&gt;normal&lt;/span&gt;: &lt;span class="nc"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_array&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// The tessellated geometry is ready to be uploaded to the GPU.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; -- {} vertices {} indices&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertices&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;indices&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Et voilÃ ! With a fairly small amount of code you can create a path and generate the vertex/index buffers that you will be able to easily render on the GPU with glium, gfx-rs, vulkano, OpenGL, or what have you.&lt;/p&gt;
&lt;p&gt;From there to pixels on your screen, it can be very simple or very complicated, that's really up to your rendering engine. You can have a look at &lt;a href="https://github.com/nical/lyon/tree/master/examples"&gt;the examples&lt;/a&gt; in the repository to get an idea. Lyon doesn't provide a renderering engine (yet), although it is something that I want to explore eventually.&lt;/p&gt;
&lt;h2&gt;What else is there in lyon?&lt;/h2&gt;
&lt;p&gt;Lyon's fill tessellator is by far where most of the work went so far. But there are a bunch of other goodies too. There is a stroke tessellator that supports most SVG stroke properties (line caps, joins, etc.), and some specialized fill and stroke tessellators for common/simpler shapes (circles, rounded rectangles, convex polygons, polylines etc.).&lt;/p&gt;
&lt;p&gt;Lyon is split into a few crates, in a way that is transparent for people who use the main crate, but helps with taming compile times and makes it possible for people to hand-pick certain features with minimal dependencies if they wish to.&lt;/p&gt;
&lt;h3&gt;lyon::geom&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_geom"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_geom"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_geom"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_geom/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lyon's &lt;a href="https://docs.rs/lyon_geom"&gt;geom&lt;/a&gt; module implements a lot of fun math for curve and line segments in 2D (splitting, flattening, intersecting, measuring, etc.) on top of euclid.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;curve&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;QuadraticBezierSegment&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ctrl&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;curve&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;intersection&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;curve&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_intersections&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;curve&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flattened_for_each&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Approximates the curve with a sequence of line segments such&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// that the approximation is never more than 0.01 away from the&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// theoretical curve.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;approximation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If you only need this and like minimal dependencies, just do &lt;code&gt;extern crate lyon_geom;&lt;/code&gt; instead of &lt;code&gt;use lyon::geom;&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;lyon::path&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_path"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_path"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_path"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_path/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lyon's &lt;a href="https://docs.rs/lyon_path"&gt;path&lt;/a&gt; module contains path-related data structures and algorithms.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;::&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// The default builder, it supports segments, bÃ©zier curves and arcs in&lt;/span&gt;
&lt;span class="c1"&gt;// absolute coordinates&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;move_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quadratc_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// This builder offers the full set of SVG path commands, and translates&lt;/span&gt;
&lt;span class="c1"&gt;// them into absolute coordinates since the default path data structure&lt;/span&gt;
&lt;span class="c1"&gt;// doesn&amp;#39;t support relative coordinates.&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;with_svg&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;move_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;relative_line_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;10.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;smooth_relative_cubic_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// This one automatically flattens the path (approximates curves with&lt;/span&gt;
&lt;span class="c1"&gt;// a sequence of line_to commands) using 0.01 as tolerance threshold&lt;/span&gt;
&lt;span class="c1"&gt;// to build the approximation.&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;flattened&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;move_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cubic_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;path_iter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;PathEvent&lt;/span&gt;::&lt;span class="n"&gt;MoveTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/*...*/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;PathEvent&lt;/span&gt;::&lt;span class="n"&gt;LineTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/*...*/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;PathEvent&lt;/span&gt;::&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/*...*/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;panic&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;unexpected curve segment {:?}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// These can be composed, you get the idea...&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;with_svg&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;flattened&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// While the builder adapters APIs provide &amp;quot;push&amp;quot;-style conversions&lt;/span&gt;
&lt;span class="c1"&gt;// between various path formats, the same kind of operations are&lt;/span&gt;
&lt;span class="c1"&gt;// provided in a &amp;quot;pull&amp;quot;-style API with iterator adapters from the&lt;/span&gt;
&lt;span class="c1"&gt;// lyon::path::iterator module.&lt;/span&gt;

&lt;span class="c1"&gt;// This path stores some curves, and the events are flattened on the&lt;/span&gt;
&lt;span class="c1"&gt;// fly by the iterator.&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path_iter&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;flattened&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Place some dots at a regular interval along a path.&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;RegularPattern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt;: &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;: &lt;span class="nc"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_tangent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_distance&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;dots&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;interval&lt;/span&gt;: &lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// Place dots 3.0 appart from one another.&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;start_offset&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path_iter&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;flattened&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;walk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start_offset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I would like to evolve this crate into a sort of swiss-army-knife of path manipulations, similar to the features &lt;a href="https://github.com/paperjs/paper.js/"&gt;paperjs&lt;/a&gt; offers, for example applying boolean operations to paths, computing convex hulls, etc.&lt;/p&gt;
&lt;p&gt;Like before, if you only want to play with paths without tessellating themyou can do &lt;code&gt;extern crate lyon_path;&lt;/code&gt; instead of &lt;code&gt;use lyon::path;&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;lyon::svg&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_svg"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_svg"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_svg"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_svg/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This module reexports the (very good) &lt;a href="https://docs.rs/svgparser"&gt;svgparser crate&lt;/a&gt; and uses it to provide a simple to build a path from an SVG path syntax:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;with_svg&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;svg&lt;/span&gt;::&lt;span class="n"&gt;path_utils&lt;/span&gt;::&lt;span class="n"&gt;build_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;svg_builder&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;M 0 0 L 10 0 L 10 10 L 0 10 z&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;lyon_tess2&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_extra"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_tess2"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_extra"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_tess2/badge.svg"&gt;&lt;/a&gt; -&lt;/p&gt;
&lt;p&gt;The lyon_tess2 crate is a very recent addition. It provides an alternative fill tessellator that wraps the &lt;a href="https://github.com/memononen/libtess2"&gt;libtess2&lt;/a&gt; C library. I use it mostly to have something to compare lyon against, but as the two tessellators don't have the exact same feature set it can be useful to others as well.&lt;/p&gt;
&lt;h3&gt;The command-line app&lt;/h3&gt;
&lt;p&gt;The repository contains command-line application that you can use to tessellate SVG paths in your favorite terminal, render paths, flattend paths, fuzz the tessellators, find bugs, generate reduced test-cases, and maybe soon make coffee. The app could be used, for example as a tool in an art building pipeline for a game engine. It's definitely great for debugging lyon.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;lyon/cli/ $ cargo run --  show -i ../assets/logo.path --fill --stroke --tolerance &lt;span class="m"&gt;0&lt;/span&gt;.01
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="screenshot" src="https://nical.github.io/images/lyon-cli-screenshot.png"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;lyon/cli/ $ cargo run --  tessellate &lt;span class="s2"&gt;&amp;quot;M 0 0 L 1 0 L 1 1 L 0 1 Z&amp;quot;&lt;/span&gt; --fill
vertices: &lt;span class="o"&gt;[(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;, &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;, &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;, &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;, &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)]&lt;/span&gt;
indices: &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;, &lt;span class="m"&gt;0&lt;/span&gt;, &lt;span class="m"&gt;2&lt;/span&gt;, &lt;span class="m"&gt;1&lt;/span&gt;, &lt;span class="m"&gt;2&lt;/span&gt;, &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;What's next?&lt;/h2&gt;
&lt;p&gt;There are many things that I'd like to see happening in the project, and it will certainly take a long time for most of them to concretise as time is a scarse resource.&lt;/p&gt;
&lt;h3&gt;Polish the fill tessellator&lt;/h3&gt;
&lt;p&gt;The fill tessellator has grown into something that I am quite happy about. It is not perfect, I definitely want to keep improving its robustness and finish implementing for the non-zero &lt;a href="https://www.w3.org/TR/SVG/painting.html#FillRuleProperty"&gt;fill rule&lt;/a&gt;, but it's already robust enough for many use cases. For example &lt;a href="http://ggez.rs"&gt;ggez&lt;/a&gt;, the rust crate to make good games easily, uses it to render polygons, and I know that a few other projects use it to make games and even to render openstreetmaps data.&lt;/p&gt;
&lt;h3&gt;A new tessellator&lt;/h3&gt;
&lt;p&gt;I want to start working on a new fill tessellator optimized for curves and able to produce a resolution-independent tessellation, probably using trapezoidal partioning like &lt;a href="https://github.com/pcwalton/pathfinder"&gt;pathfinder&lt;/a&gt;. The new tessellator will work best with curves but will not be as good for polygons as a monotone tessellator, so the current tessellator is definitely here to stay.&lt;/p&gt;
&lt;h3&gt;A high level renderer on top of lyon&lt;/h3&gt;
&lt;p&gt;This was my initial goal when the project started forever ago. As it turns out tessellation was a fascinatingly and hard topic and I decided to focus on it for a while. It would be great to play with a 2D renderer for interactive content (like games and &lt;a href="https://beesandbombs.tumblr.com/"&gt;creative coding&lt;/a&gt;) and see what a 2D API designed for your GPU would look like (as opposed to GPU backends for APIs that were designed for CPUs a decade or two ago for static content, which is the state of most 2D APIs these days).&lt;/p&gt;
&lt;h3&gt;Documentation&lt;/h3&gt;
&lt;p&gt;There was a big documentation push a year ago and it was worth it. Let's do this again.&lt;/p&gt;
&lt;h3&gt;Maybe the next feature is going to be your idea&lt;/h3&gt;
&lt;p&gt;Or even your next pull request, Who knows?&lt;/p&gt;
&lt;h2&gt;Big thanks to all contributors&lt;/h2&gt;
&lt;p&gt;Now is a good time to underline that I didn't do all of this work alone. I want to thank again all the &lt;a href="https://github.com/nical/lyon/wiki/Contributors#contributors"&gt;awesome individuals&lt;/a&gt; who submitted contributions, big and small, to the project. This project is too large for a single person's spare time, and seeing people come and give a hand is the most rewarding and motivating thing. Also thanks a lot to everyone who is using lyon and reporting bugs!&lt;/p&gt;
&lt;p&gt;Want to join the fun? Check out the &lt;a href="https://github.com/nical/lyon/blob/master/CONTRIBUTING.md"&gt;contribution guidelines&lt;/a&gt;, get started on the &lt;a href="https://github.com/nical/lyon/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22"&gt;easier issues&lt;/a&gt;, and don't hesitate to ask any question on &lt;a href="https://gitter.im/lyon-rs/Lobby"&gt;gitter&lt;/a&gt; or irc in #rust-gamedev.
I want this project to be as fun and welcoming as possible and I would love it to be more of a team effort than a one man show. If you are running into issues contribting, &lt;a href="https://github.com/nical/lyon/issues/32"&gt;let me know&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="lyon stickers photo" src="https://nical.github.io/images/lyon-stickers.jpg"&gt;&lt;/p&gt;
&lt;p&gt;There are lyon stickers which is the ultimate proof that the project is cool.&lt;/p&gt;</content><category term="lyon, rust"></category></entry></feed>