<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Eight million pixels and counting</title><link href="https://nical.github.io/" rel="alternate"></link><link href="https://nical.github.io/feeds/all.atom.xml" rel="self"></link><id>https://nical.github.io/</id><updated>2019-02-17T00:00:00+01:00</updated><entry><title>Lyon in 2018</title><link href="https://nical.github.io/posts/lyon-2018.html" rel="alternate"></link><published>2019-02-17T00:00:00+01:00</published><updated>2019-02-17T00:00:00+01:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2019-02-17:/posts/lyon-2018.html</id><summary type="html">&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;About a year ago I published &lt;a href="https://nical.github.io/posts/lyon-intro.html"&gt;
"Introduction to lyon: 2D vector graphics rendering on the GPU in rust"
&lt;/a&gt; on this blog. Lyon was in version &lt;a href="https://docs.rs/lyon/0.8.8/lyon/"&gt;&lt;code&gt;0.8.8&lt;/code&gt;&lt;/a&gt; back then and I recently published &lt;a href="https://docs.rs/lyon/0.13.0/lyon/"&gt;&lt;code&gt;0.13.0&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In 2018 my activity on the project has varied depending on the time …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;About a year ago I published &lt;a href="https://nical.github.io/posts/lyon-intro.html"&gt;
"Introduction to lyon: 2D vector graphics rendering on the GPU in rust"
&lt;/a&gt; on this blog. Lyon was in version &lt;a href="https://docs.rs/lyon/0.8.8/lyon/"&gt;&lt;code&gt;0.8.8&lt;/code&gt;&lt;/a&gt; back then and I recently published &lt;a href="https://docs.rs/lyon/0.13.0/lyon/"&gt;&lt;code&gt;0.13.0&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In 2018 my activity on the project has varied depending on the time and energy I have had left after work and other activities. As it turns out, working on &lt;a href="http://mozillagfx.wordpress.com/"&gt;getting WebRender shipped in Firefox&lt;/a&gt; is at the same time amazing and very demanding, and what's left of my brain after a good day of work isn't always up to some of the ambitions I have planned for lyon. Fortunately I am not the only one who contributed to the project, and while progress was slow on the most ambitious plans, I did spend some time on smaller features and polish.&lt;/p&gt;
&lt;p&gt;I'll get to these big plans towards the end of this post. In the mean time let's look at some of the highlights of what changed in lyon in 2018.&lt;/p&gt;
&lt;h2&gt;lyon_geom&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_geom"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_geom"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_geom/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I want to start with an epic contribution from &lt;a href="https://github.com/kleintom"&gt;Tom Klein&lt;/a&gt;: The addition of a robust cubic bézier intersection algorithm using fat line clipping. You can read about this journey in the original &lt;a href="https://github.com/nical/lyon/pull/422"&gt;pull request&lt;/a&gt; and &lt;a href="https://github.com/nical/lyon/pull/427"&gt;followup improvements&lt;/a&gt;. Suffice to say, I'm impressed with the quality and rigor of the work Tom put in this feature.&lt;/p&gt;
&lt;p&gt;Tom also &lt;a href="https://github.com/nical/lyon/pull/419"&gt;added&lt;/a&gt; an elliptic arc to cubic bézier approximation (&lt;a href="https://docs.rs/lyon_geom/0.12.2/lyon_geom/arc/struct.Arc.html#method.for_each_cubic_bezier"&gt;doc link&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;There were other additions such as tight bounding rectangle calculation for elliptic arcs, improvements and fixes to the various curve approximation algorithms and a lot of API ergonomic improvements.&lt;/p&gt;
&lt;p&gt;This year has confirmed the trend that a number of people are using lyon_geom without the rest of lyon. The way the lyon crates are separated seems to have paid off in letting people who only want curve math tools get a minimal dependency.&lt;/p&gt;
&lt;h2&gt;lyon_tessellation&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_tessellation"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_tessellation"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_tessellation"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_tessellation/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To me, &lt;a href="https://docs.rs/lyon_tessellation/0.13.0/lyon_tessellation/struct.FillTessellator.html"&gt;the fill tessellator&lt;/a&gt; is the most important piece of the whole project. The majority of the changes to the fill tessellator were bug fixes, almost all of them related to dreadful numerical precision issues when paths have many self-intersections and in particular when a lot of these self-intersections are almost at the same position. This type of paths isn't representative of human generated content but the robustness of the tessellator is important to me and I want to keep improving it.&lt;/p&gt;
&lt;p&gt;As far as API changes are concerned, I added the possibility to chose the type of the generated indices of the vertex/index buffer pairs. Before that, indices were always &lt;code&gt;u16&lt;/code&gt; and some users ran into the limit when generating large amount of geometry with a single path or when tessellating too many paths in the same vertex and index buffer pair. The tessellator now internally works with &lt;code&gt;u32&lt;/code&gt; indices and the convenience &lt;a href="https://docs.rs/lyon_tessellation/0.13.0/lyon_tessellation/struct.BuffersBuilder.html"&gt;&lt;code&gt;BuffersBuilder&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://docs.rs/lyon_tessellation/0.13.0/lyon_tessellation/struct.VertexBuffers.html"&gt;&lt;code&gt;VertexBuffers&lt;/code&gt;&lt;/a&gt; output can be parametrized over the index type to provide the choice of &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt; or anything else that can be converted to a &lt;code&gt;VertexId&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In addition, the &lt;code&gt;GeometryBuilder&lt;/code&gt; trait and the tessellators are set up to properly handle running out of indices, interrupting the tessellation and returning an error instead of causing a panic as it previously did.&lt;/p&gt;
&lt;p&gt;This might sound like a detail but several people ran into it and the way the tessellator used to panic when running out of vertex ids was confusing so I am happy that this is now a thing of the past. My initial worry was that the added glue to forward and handle errors would regress performance (which it initially did by about 6%), but with a small amount profiling and tweaks I got the performance back within noise range of the original scores (on the benchmarks in the repository).&lt;/p&gt;
&lt;h2&gt;lyon_path&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_path"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_path"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_path"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_path/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This crate has received more attention than usual lately.&lt;/p&gt;
&lt;p&gt;The first thing people who update from earlier versions of lyon will notice is probably that &lt;code&gt;lyon::path::default::Path&lt;/code&gt; is now &lt;code&gt;lyon::path::Path&lt;/code&gt;. But there have been some more interesting developments than this namespace change.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/iterator/index.html"&gt;iterator APIs&lt;/a&gt; got a pretty major revamp. Previously the various flavors of path iterators would let you iterate over events such as &lt;code&gt;MoveTo(Point)&lt;/code&gt;, &lt;code&gt;Close&lt;/code&gt;, &lt;code&gt;LineTo(Point)&lt;/code&gt; and equivalent curve segments types, in a postscript fashion similar to how the paths are created, in which we don't repeat the start of the event since we already provided it as the end of the previous one.
This was simple to implement since it maps to how the path is stored, but pretty much every consumer of the API would have to keep track of both the previous end of segment and the starting position of the curve to do any meaningful work with the segments of the path.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;PathEvent&lt;/code&gt; enum looked like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;pub&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="nc"&gt;PathEvent&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;MoveTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;LineTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;QuadraticTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// control point, to&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// etc.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And now looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;pub&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="nc"&gt;PathEvent&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;MoveTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LineSegment&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LineSegment&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Quadratic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QuadraticBezierSegment&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// etc.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In other words, I shifted the burden of tracking this information from the user to &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/struct.Iter.html"&gt;the iterator&lt;/a&gt; implementation by making path events contain the actual segments and by providing the closing segment in &lt;code&gt;PathEvent::Close(LineSegment&amp;lt;f32&amp;gt;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I also removed &lt;code&gt;PathSegment::Arc&lt;/code&gt; (elliptic arcs automatically get approximated with a sequence of cubic bézier curves) and simplified the &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/iterator/trait.PathIterator.html"&gt;&lt;code&gt;PathIterator&lt;/code&gt; trait&lt;/a&gt; which is now a simple extension trait implemented for all &lt;code&gt;Iterator&amp;lt;Item = PathEvent&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There is also a new &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/struct.Cursor.html"&gt;&lt;code&gt;Cursor&lt;/code&gt; API&lt;/a&gt; which makes it possible to refer to specific positions within a path and work with portions of paths instead of always iterating over the entire path from the beginning.&lt;/p&gt;
&lt;p&gt;A &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/iterator/trait.FlattenedIterator.html#method.length"&gt;helper to approximate the length of a path&lt;/a&gt; using adaptive curve flattening was added, although Raph Levien wrote about &lt;a href="https://raphlinus.github.io/curves/2018/12/28/bezier-arclength.html"&gt;a faster way to evaluate the length of bézier curve segments&lt;/a&gt; which he implemented in in the &lt;a href="http://github.com/linebender/kurbo"&gt;kurbo&lt;/a&gt; crate. Perhaps some of this good stuff will make its way into lyon as well eventually.&lt;/p&gt;
&lt;p&gt;In the long term I want to experiment with more changes to the path data structure, for example making it generic over the vertex type to allow &lt;code&gt;f64&lt;/code&gt; coordinates and potentially arbitrary per-point attributes (for example one could want to store colors, line width, etc.).&lt;/p&gt;
&lt;h2&gt;lyon_algorithms&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_algorithms"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_algorithms"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_algorithms"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_algorithms/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A new crate was introduced this year! &lt;a href="https://docs.rs/lyon_algorithms/"&gt;lyon_algorithms&lt;/a&gt; contains a number of path related transformations and algorithms such as &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/hatching/index.html"&gt;generating hatching and dotting patterns&lt;/a&gt;, &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/splitter/struct.Splitter.html"&gt;splitting paths&lt;/a&gt;, &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/aabb/index.html"&gt;computing bounding boxes&lt;/a&gt;, &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/raycast/fn.raycast_path.html"&gt;ray casting&lt;/a&gt; and &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/walk/index.html"&gt;walking along a path at constant speed&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I wrote most of these algorithms for fun. I don't think I will pursue the same robustness goals as the fill tessellator there (path splitting has some very difficult edge cases when several segments overlap exactly for example), but I think that they are good enough to be useful to a lot of people.&lt;/p&gt;
&lt;p&gt;I'd love to add more algorithms there, like boolean operations, path simplification, path smoothing, path interpolation, and so on.&lt;/p&gt;
&lt;p&gt;I have used these algorithms to generate procedural shapes and print them with my &lt;a href="https://www.axidraw.com/"&gt;axidraw&lt;/a&gt; and it's a ton of fun. Hopefully, some people in the plotting community will find them useful.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Hatching example" src="https://nical.github.io/images/hatching-screenshot.png"&gt;&lt;/p&gt;
&lt;h2&gt;Work in progress&lt;/h2&gt;
&lt;p&gt;I mentioned at the beginning of the post that I have been making slow progress on two fronts:&lt;/p&gt;
&lt;h3&gt;A new fill tessellator&lt;/h3&gt;
&lt;p&gt;This work is happening in the &lt;a href="https://github.com/nical/lyon/pull/334"&gt;new-tess branch&lt;/a&gt;. The main motivations for this are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Better robustness against numerical precision issues. In broad strokes, the idea is to organize the algorithm so that it can detect and recover from precision bugs that break the invariants of the algorithm. It is a little hard to describe, but in a nutshell the approach is to accept that some arithmetic will produce results that break the invariant of the algorithm and split iterations of the main loop into an analysis phase where we get a chance to detect the error, backtrack one step and recover from it, and a mutation phase. In contrast the current tessellator interleaves mutations of its internal state with analysis of the geometry in a way that makes it hard to interrupt the iteration and recover if a bad state is detected.&lt;/li&gt;
&lt;li&gt;Support arbitrary vertex attributes. Today it is hard to associate external data such as colors or bone weights for animation to each vertex and use it in the output of the tessellator.&lt;/li&gt;
&lt;li&gt;Move away from fixed point numbers which the current tessellator uses internally. I originally thought that they would be the key to taming precision issues, but it didn't work out that well, and introduced new issues like a limited range of numbers that the tessellator can represent internally.&lt;/li&gt;
&lt;li&gt;Support for more fill rules (even-odd is the only currently supported fill rule in the current tessellator).&lt;/li&gt;
&lt;li&gt;Handling quadratic bézier curves directly in the tessellator. The tessellator would be able to either flatten curves on the fly during tessellation, or produce a mesh in which the curves could be evaluated in a fragment shader or tessellation shader. This goal longer term than the others, though.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So far the new tessellator is able to tessellate all of the non-self intersecting curves I have thrown at it (good thing lyon has a pretty large test suite), but doesn't detect intersections yet, and that's on purpose: ignoring intersections is a great way to mess the internal state of the algorithm up and see if it can recover and continue from there. I'll implement detecting and handling intersections eventually of course.
I have put no effort in performance yet (will get to that when the new tessellator is close to being usable), it doesn't handle curves and I haven't settled on a way to model the API to support arbitrary vertex attributes when vertices are added during tessellation (again because of self-intersections).&lt;/p&gt;
&lt;h3&gt;Higher quality monotone tessellation&lt;/h3&gt;
&lt;p&gt;By "higher quality", I mean reducing the amount of thin triangles that are generated by the algorithm. Long thin triangles have undesirable properties. For example they tend to produce precision issues when used in certain algorithms like physics simulation, and be &lt;a href="https://www.g-truc.net/post-0662.html"&gt;slower to render on the GPU&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The monotone polygon decomposition approach used in lyon has a tendency to produce long horizontal triangles in some cases. I have a prototype that improves upon this but fails in some cases. To be continued.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Thin triangles illustration" src="https://nical.github.io/images/rustfest/adv-monotone.svg"&gt;&lt;/p&gt;
&lt;h2&gt;Wrapping up&lt;/h2&gt;
&lt;p&gt;2018 Was a good year for lyon. In this post I put forth Tom Klein's contribution, but other people also helped get the project where it is today. If your name is on &lt;a href="https://github.com/nical/lyon/wiki/Contributors"&gt;the contributor list&lt;/a&gt;, then you are awesome and I thank you.&lt;/p&gt;
&lt;p&gt;Hopefully 2019 will be the year where the new tessellator matures and replaces the current one and maybe the start of a small vector graphics rendering crate built on top of gfx-hal.&lt;/p&gt;</content></entry><entry><title>2d graphics in Rust discussion - A look at GPU memory management</title><link href="https://nical.github.io/posts/rust-2d-graphics-02.html" rel="alternate"></link><published>2018-10-28T00:00:00+02:00</published><updated>2018-10-28T00:00:00+02:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2018-10-28:/posts/rust-2d-graphics-02.html</id><summary type="html">&lt;p&gt;In this post I'll write about an piece of the low level details of an hypothetical rust 2d graphics crate built on top of &lt;a href="https://github.com/gfx-rs/gfx"&gt;gfx-hal&lt;/a&gt;. Gfx provides a vulkan-like interface implemented on top of vulkan, d3d12, metal or flavors of OpenGL. just like the &lt;a href="https://nical.github.io/posts/rust-2d-graphics-01.html"&gt;previous post&lt;/a&gt; this is in the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post I'll write about an piece of the low level details of an hypothetical rust 2d graphics crate built on top of &lt;a href="https://github.com/gfx-rs/gfx"&gt;gfx-hal&lt;/a&gt;. Gfx provides a vulkan-like interface implemented on top of vulkan, d3d12, metal or flavors of OpenGL. just like the &lt;a href="https://nical.github.io/posts/rust-2d-graphics-01.html"&gt;previous post&lt;/a&gt; this is in the context of recent discussions about a 2d graphics crate in rust.&lt;/p&gt;
&lt;p&gt;I won't actually write much about 2d graphics specific things this time, because a lot of these low level concerns are agnostic to whether the rendered content is in two or three dimensions. I'll mostly focus on memory management and command submission.&lt;/p&gt;
&lt;p&gt;This low level thing I am going to talk about isn't a 2d graphics API that most users would play with but rather a base component on top of which various rendering techniques could be implemented (for example using &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt;, &lt;a href="https://github.com/pcwalton/pathfinder"&gt;pathfinder&lt;/a&gt; or some other approach), and this base component would be independent of these rendering techniques.&lt;/p&gt;
&lt;h2&gt;Organizing the input of drawing commands on the GPU&lt;/h2&gt;
&lt;p&gt;Let's have a look at &lt;a href="https://github.com/servo/webrender"&gt;WebRender&lt;/a&gt;. Most drawing primitives in WebRender use very simple geometry (axis-aligned rectangles) with shaders of varying complexity that compute directly on the GPU what happens to the pixels covered by the geometry. If you've ever done serious work with GPU, one of your primary concerns most likely was to batch rendering commands and avoid state changes. To render a few thousand rectangles, it would be terribly inefficient to have a loop on the CPU that sets some parameters and kicks a drawing command for each rectangle. So what we do is write a lot of parameters into buffers which are sent to the GPU, and kick a few drawing commands, that will each render maybe thousands of rectangles in one go using instancing.
The drawing parameters we write into the buffer contain information such as the position and size of the rectangle in layout space, a transformation to go from layout space to screen space, some flags about whether some anti-aliasing must be done, the positions and sizes of some source images in a texture atlas if need be (for example to apply a texture or a mask), the z-index of the primitive to write into the depth buffer, etc.
The vertex shader uses an instance id to find the right information in a per-instance parameter buffer, transforms the geometry (a unit quad) into the right rectangle on screen, forwards some data to the fragment shader and the latter executes the per pixel logic (read from the source textures, apply some effect, write output color, etc.).&lt;/p&gt;
&lt;p&gt;&lt;img alt="gpu memory organization example" src="https://nical.github.io/images/gpu-mem-01.svg"&gt;&lt;/p&gt;
&lt;p&gt;This approach is fairly generic, not particular to WebRender (a lot of games do this sort of thing) and works quite well.
What's interesting here is that if you get to write the shaders yourself you have a lot of flexibility in how the input data is organized in GPU memory. You can put all of the parameters for a given instance contiguous together or add levels of indirection, share some common parameters among many instances or even devise your own compression scheme for your data. All that matters is for the CPU code to know how to writes bytes and the shader to know how to find the data in GPU memory and interpret it the right way, and then it is up to you to decide what trade-off to make about simplicity, memory usage and data locality.&lt;/p&gt;
&lt;p&gt;I like to think of the problem of submitting commands to the GPU as some sort of encoding/decoding problem. Got data on one side, some binary representation in GPU buffers and need to read that correctly in the shader. As such, submitting commands is very tied to GPU memory management since it amounts to writing the correct information in the right place.
In the purpose of a 2d graphics library, what kind of representation would we want? Well we don't know because the shape the data you write into GPU memory may depend on the details of the rendering technique itself and I mentioned earlier that I want this low level component to be agnostic to that. Some other layer above will deal with it and for now we can focus providing a way to write data into these GPU buffers.&lt;/p&gt;
&lt;h2&gt;Dealing with GPU memory allocation&lt;/h2&gt;
&lt;p&gt;Let's first have a look at some properties I want from a low level GPU memory management system:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Be able to write commands from several threads in parallel.&lt;/li&gt;
&lt;li&gt;Be able to separate memory that is rarely updated from memory that we update often in order to minimize transfer and choose the right kind of memory heap.&lt;/li&gt;
&lt;li&gt;The system should be embeddable in another application that uses gfx.&lt;/li&gt;
&lt;li&gt;Ideally the shader should not have to care about whether a particular property is static or dynamic.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Legacy graphics APIs had a lot of memory management magic done in the driver. Modern APIs such as vulkan move this responsibility to the user of the API (us). Simply allocating a lot of small memory segments has a lot overhead. &lt;a href="https://youtu.be/zSG6dPq57P8?t=1163"&gt;AMD's recommendation&lt;/a&gt; is to allocate large chunks of memory segments of 256 MiB and manage sub-allocations within these coarse chunks, others talk about 128 MiB blocks, &lt;a href="https://developer.nvidia.com/vulkan-memory-management"&gt;nVidia's recommendation&lt;/a&gt; is to manage all allocations out of as few as possible large contiguous memory chunks.&lt;/p&gt;
&lt;p&gt;So we can decide to have these large memory blocks with various allocation schemes within them, from a simple bump allocator to a general purpose fully-featured allocator.&lt;/p&gt;
&lt;p&gt;For per-frame data which is overwritten each time, a bump allocator looks like a good fit: It is simple, fast and we can easily write a lock-free one that is usable in parallel. For completely static (as in very long-lived) allocations, bump allocators can also work well since we don't need to worry about fragmentation. The area in the middle is a bit tricker. I don't have a precise definitive allocation strategy to provide here, other than that in my opinion, nesting simple and efficient allocators is the way to go. Group memory allocations into blocks of the same lifetime that get deallocated in one go, and try to keep the complicated parts of memory managements for fewer coarser chunks, also try to group allocations by update frequency. In other words, use specific, simple and deterministic allocation strategies rather than relying on a single complicated one-size-fits-all allocation interface like if you had jemalloc for your GPU. Making such a general purpose allocator is for one very hard, and ensuring good and deterministic performance characteristics is even harder.&lt;/p&gt;
&lt;p&gt;This idea of nested allocators is a good fit for something that can be embedded into another graphics engine. For example the coarse allocations could be requested to the embedder and the 2d renderer would manage its own allocations inside of them.
For multi-threading this is also good: Some thread-safe allocator can allocate chunks in parallel, and these chunks could be managed independently in single-thread fashion but each on their single thread by a nested allocator that is hard to make thread-safe.&lt;/p&gt;
&lt;p&gt;Some allocations are best managed manually (explicit allocation and deallocation), while for some other things, using a cache can be more interesting: Each frame, the CPU side requests that the allocations that are used within the cache stay alive, and if an allocation isn't used for a long time, the cache implicitly deallocates it. The next time the allocation is requested, the cache will politely tell the source of the request that the allocation doesn't exist anymore, a new allocation is made and the data is transfered again. A lot the GPU memory management in WebRender is done that way. Having the right heuristics about when to expire cache entries is not always simple.&lt;/p&gt;
&lt;p&gt;So far I talked about allocations in the sense of figuring out how many bytes at which offset to reserve in GPU memory for this and that, but we also want to write into these allocations. Often times people think of allocating and writing into memory as single thing. When writing &lt;code&gt;let five = Box::new(5)&lt;/code&gt; you both ask the allocator to figure out where the value will be and write the value in memory. But sending data to the GPU isn't that simple. In general you can't assume that the memory you are writing to on the CPU is the one that gets read in the shaders. There are several memory heaps with different characteristics (CPU-visible, GPU-visible, fast/slow to read/write on the CPU/GPU, etc.). In practice this means that for a lot things the data is first written into a staging buffer that is CPU-visible, then copied from there into memory that is fast to read from the shaders.&lt;/p&gt;
&lt;p&gt;&lt;img alt="staging buffer" src="https://nical.github.io/images/gpu-mem-02.svg"&gt;&lt;/p&gt;
&lt;p&gt;One strategy could be to work with a large GPU buffer for the shader to read and generally smaller staging buffers into which we write only the parts that have changed. In this scheme the shader gets to read from a single contiguous buffer containing static and dynamic data alike and doesn't have to be aware of that. This is at the cost of copying from the staging buffer for data that we now will only read for a single frame. If a lot of data needs to be updated and read only once each frame, using another type of GPU memory heap that is both accessible to the CPU and the GPU, is slower to read in the shader but depending on how the data is read it might still be faster than the copy of the staging buffer. &lt;a href="https://youtu.be/zSG6dPq57P8?t=991"&gt;An example&lt;/a&gt; given for this type of memory heap is particle positions in a game, where by definition we know all of it will change each frame. The downside is that the shader can't pretend it is in a unified address space with the rest, so it isn't agnostic to what is animated and what is not. This might not be a good fit for cases where, say, some of the positions are animated while others are not and it all goes through the same code path in the shader.
Another thing to be careful about is that some types of memory heaps use write-combined memory which is ideal to fill the staging buffer but can perform poorly if we don't pay attention to how we write into it. So we have to allocate full aligned multiple-of-cacheline sized chunks and avoid random access.&lt;/p&gt;
&lt;h2&gt;What's next?&lt;/h2&gt;
&lt;p&gt;Phew. That was a lot of words just for pushing some bytes to the GPU! I merely presented some challenges, proposed certain directions from very far away and haven't even really talked about rendering (the fancy tricks that goes into those shaders, generating the geometry and all).&lt;/p&gt;
&lt;p&gt;But I believe this is an important part of the foundation. It is built upon mostly independent pieces and that's already some code that needs writing. Fortunately, this weekend was the first in a while that I had time to sit down and do that so I took one of gfx-hal examples and started writing a few things around it. So far I only have a simple &lt;a href="https://github.com/nical/lyon/blob/371af479cd743c102487835a74299ac50967cadd/renderer/src/allocator.rs#L4"&gt;bump allocator&lt;/a&gt;, some &lt;a href="https://github.com/nical/lyon/blob/371af479cd743c102487835a74299ac50967cadd/renderer/src/writer.rs#L93"&gt;glue to use it and write into memory&lt;/a&gt; from multiple threads, a simple and dumb &lt;a href="https://github.com/nical/lyon/blob/371af479cd743c102487835a74299ac50967cadd/renderer/src/allocator.rs#L54"&gt;retained allocator&lt;/a&gt; for coarse allocations, some &lt;a href="https://github.com/nical/lyon/blob/371af479cd743c102487835a74299ac50967cadd/renderer/src/gfx.rs"&gt;reexports of the gfx types&lt;/a&gt; without generics all over the place (since the backend is selected with feature flag), and various &lt;a href="https://github.com/nical/lyon/blob/371af479cd743c102487835a74299ac50967cadd/renderer/src/lib.rs#L99"&gt;small utilities&lt;/a&gt;. That's not much, I'm still spending time getting familiar with gfx, but that's a humble start.&lt;/p&gt;
&lt;p&gt;I'll end this post with hand-wavey overview of how I see this stuff fitting into the bigger picture:&lt;/p&gt;
&lt;p&gt;&lt;img alt="boring architecture diagram" src="https://nical.github.io/images/gpu-mem-03.svg"&gt;&lt;/p&gt;
&lt;p&gt;From bottom to top there is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A gfx-device that is owned by an embedder.&lt;/li&gt;
&lt;li&gt;The embedder can be the default one or some glue to integrate with a specific engine or app).&lt;/li&gt;
&lt;li&gt;The low level components contain anything that is mostly independent of the rendering technique, for example a lot of the memory management code that I wrote about in this post. The goal of the low level components is to make it easy to write efficient rendering components without having each of them reinvent the common pieces. Rendering components do the more interesting stuff: They register passes, shaders, and implement fun rendering techniques. An example of rendering component could be a glyph renderer using pathfinder. Another one could be a tessellated polygon renderer that uses lyon, another one could be something that is optimized for rendering many axis-aligned rectangles as is common for UIs. Rendering components inform the command submission system which draw calls are order-independent as well as some global requirements such as depth/stencil behavior, etc. This lets the low level pieces figure out an efficient batching strategy.&lt;/li&gt;
&lt;li&gt;You see on top of that several "API" boxes. These take care of high level logic and providing user facing APIs. Each API would have to make different tradeoffs and focus on different use cases, picking whatever rendering components they want to use.
As much as possible I would like to avoid compromises outside of the "API" boxes which will be potentially high level abstractions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'm intentionally describing this in very broad terms. The idea behind separating things this way is to be able to experiment with various rendering techniques without starting from scratch each time, and also aim for an extendable architecture if things work out. There is a lot of pieces missing and the boundaries will move as real code gets written but this sets a general direction I am happy with for a low level GPU based 2d graphics library.&lt;/p&gt;</content></entry><entry><title>Following up on the 2d graphics in Rust discussion</title><link href="https://nical.github.io/posts/rust-2d-graphics-01.html" rel="alternate"></link><published>2018-10-14T00:00:00+02:00</published><updated>2018-10-14T00:00:00+02:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2018-10-14:/posts/rust-2d-graphics-01.html</id><summary type="html">&lt;p&gt;Raph Levien recently published &lt;a href="https://raphlinus.github.io/rust/graphics/2018/10/11/2d-graphics.html"&gt;A crate I want: 2d graphics&lt;/a&gt; on his blog, which started some interesting discussions &lt;a href="https://www.reddit.com/r/rust/comments/9nhhh8/a_crate_i_want_2d_graphics/"&gt;on reddit&lt;/a&gt;. At the same time there is a nascent discussion on the &lt;a href="https://github.com/draw2d/rfcs/issues/1"&gt;draw2d&lt;/a&gt; repository (which doesn't have any code at this point) about a potential 2d graphics crate.&lt;/p&gt;
&lt;p&gt;These discussions contain …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Raph Levien recently published &lt;a href="https://raphlinus.github.io/rust/graphics/2018/10/11/2d-graphics.html"&gt;A crate I want: 2d graphics&lt;/a&gt; on his blog, which started some interesting discussions &lt;a href="https://www.reddit.com/r/rust/comments/9nhhh8/a_crate_i_want_2d_graphics/"&gt;on reddit&lt;/a&gt;. At the same time there is a nascent discussion on the &lt;a href="https://github.com/draw2d/rfcs/issues/1"&gt;draw2d&lt;/a&gt; repository (which doesn't have any code at this point) about a potential 2d graphics crate.&lt;/p&gt;
&lt;p&gt;These discussions contain a lot of interesting comments. One notable thing is that "2d graphics" means different things to different people. Some people want to render UIs, some people want to make games with rich vector graphics, some people want to be able to render complex but static SVG documents, some people want something designed for modern GPUs, some people want a library that can be used without a GPU, some want it low level, other want it high level, &lt;em&gt;et caetera&lt;/em&gt;.
Having worked with and on different approaches to 2d graphics rendering, I am convinced that 2d graphics isn't a single problem with an established solution, but rather collection of different problems which are best solved with very different solutions.&lt;/p&gt;
&lt;p&gt;Because of that I would like this discussion to branch into several specific topics. In this post I'll talk about 2d graphics for the web and for user interfaces (a case could be made about separating the two of course), to a large extent with the intent to underline how specific the needs of these use cases are. Before I do that I'll write a few words about "canvas-like" graphics APIs.&lt;/p&gt;
&lt;h2&gt;Canvas, Cairo, Skia, QPainter - The immediate mode painting model&lt;/h2&gt;
&lt;p&gt;&lt;img alt="canvas-like APIs" src="https://nical.github.io/images/canvas-api.svg"&gt;&lt;/p&gt;
&lt;p&gt;A lot of the most common 2d graphics APIs look somewhat similar: We have a context object which holds various drawing states like the current transform, pattern, or clip, we have a way to describe paths in post-script fashion (for example &lt;code&gt;context.move_to&lt;/code&gt;, &lt;code&gt;context.line_to&lt;/code&gt;, or if we are lucky, actual path objects that can be retained and reused). The general mental model is that you specify each drawing operation in back to front order and pixels are being painted immediately at each operation (or this is what the API pretends) but in practice drawing might be deferred so that the underlying implementation can take advantage of knowing about all of the elements and perform some global optimizations. For example CPU backends tend paint each drawing command individually, but GPU implementations pretty much need to be able to perform global optimizations in order to get acceptable performance. Another important aspect of these APIs is that they don't retain a description of the scene, which means that in order to render interactive content, you will submit the commands again each frame with some modifications for the parts that are changing. A common optimization when using this drawing model is for the user to track which region of the final image has changed and only redraw that part (in Firefox we call it invalidation).&lt;/p&gt;
&lt;p&gt;Generally, implementing an efficient GPU backend for a pre-existing canvas-like API has proven to be difficult (doable but difficult). A lot of these APIs were designed before GPUs existed or became what they are now, and often a lot of expensive transformations need to happen between the API and the underlying GPU command submissions.&lt;/p&gt;
&lt;h2&gt;Compositors&lt;/h2&gt;
&lt;p&gt;When motion comes into play (through animations or scrolling), re-rendering rectangles, paths, text and whatever else is moving at a high frame rate can become expensive with these drawing models. A very common solution to this problem is to group elements that tend to move together and paint them into retained surfaces that are often called layers (at least in the world of web browsers). Scrolling then becomes a matter of moving one or several layers and compositing them together to form the resulting image. This compositing operation is the job of... the compositor. Compositing within an application is very similar to compositing for a window manager, to the point where all modern window managers now provide APIs to let applications delegate the work of compositing their layers to the window manager, which avoids one compositing step, saves cycles, memory bandwidth and power. It is somewhat painful that all platforms expose this functionality in subtly different ways, but I think that it would be a mistake for any new UI toolkit to ignore it if they have a concept of retained surfaces.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Gecko compositor" src="https://nical.github.io/images/gecko-compositor.png"&gt;&lt;/p&gt;
&lt;h2&gt;Rendering web pages and UIs&lt;/h2&gt;
&lt;p&gt;By now I already gave away some of the details about how a lot of web browsers and UI toolkits work: an immediate mode painting abstraction, on top of which an invalidation system and a compositor were implemented to paper over the difficulty of rendering at 60 frames per second (without draining too much power). This is pretty much how Firefox (and most other browsers), Gtk and Qt have been historically approaching 2d graphics. This model is also to some extent something that Firefox, Gtk and Qt have or are in the process of going away from. I'll get to that in a moment, but before that I want to look at what drawing primitives are important for a web browser and a UI toolkit:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Text. Oh text. Text is of course very important in this context and &lt;em&gt;must&lt;/em&gt; have a particular look in each platform because a lot of users are bothered when hinting or anti-aliasing in an app doesn't match the look of the rest of the platform. In practice this means a lot of graphics libraries go through great lengths and pain to use the font rendering system of each platform they support. Text is hard. I wont get into these details but the people who implement the myriad of things that happen between loading a font file and the letters of this blog post showing up on your screen are heroes (no self-congratulations, I only touched very small portions of that). Patrick Walton is working on the &lt;a href="https://github.com/pcwalton/font-kit"&gt;font-kit crate&lt;/a&gt; which will hopefully erase some of the pain of dealing with font on each platform. I haven't used it yet but it's something to keep an eye on. Unless you are on a very high dpi screen, sub-pixel positioning and anti-aliasing make text a lot easier and nicer to read. One might decide to only target high dpi displays and punt on these features, but I wouldn't call that an easy decision and it will rule out some use case for sure.&lt;/li&gt;
&lt;li&gt;Simple shapes: mostly axis aligned rectangles and rounded rectangles, filled and their outlines.&lt;/li&gt;
&lt;li&gt;Very complex clipping scenarios: That one might not be necessary for some UI toolkits, but I'll mention it because clipping is a hard problem when your job is to render web pages. In any case it took quite a bit of trial and error to get that work with all use cases in WebRender.&lt;/li&gt;
&lt;li&gt;A few effects like drop shadows and blurs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Notice how I didn't mention arbitrary paths? Of course these need to be implemented in a web browser but without them you can already render a large portion of the web. Any modern UI toolkit also needs to render arbitrary vector graphics to provide resolution independent icons and some types of UI widgets, but the need doesn't compare to the heaps of rectangles and text that compose UIs and web pages.
Since you still need to support both arbitrary vector graphics and these specific simple shapes, you can simply focus on rendering the complex cases and you'll get the simple case for free, right? Except that in doing so, by not making the overwhelmingly most common case a first class citizen of the system a lot of potential for performance optimization would be lost.
Today, WebRender doesn't know how to render arbitrary shapes. It's main primitives are (rounded) rectangles and more complex shapes just go through a fall-back mechanism that is part of Gecko and provides WebRender with the resulting content already rasterized. We'll eventually implement path rendering on the GPU but the current situation is good enough for us to ship WebRender first with the fall-back.
My understanding is that the situation is similar with Gsk (Gtk's next generation rendering infrastructure): arbitrary vector graphics are rasterized using Cairo on the CPU while great care goes into rasterizing rectangles on the GPU.&lt;/p&gt;
&lt;p&gt;Interestingly, for a lot of people path rendering is the central theme when thinking about 2d graphics. My point isn't to state what features are more important than others for a 2d graphics library, but really to stress how different the use cases are and that Rust does not need a single 2d graphics crate, but several, each with different goals and trade-offs.&lt;/p&gt;
&lt;p&gt;Speaking of focus, I will now attempt to get my chaotic train of thought together and come back to the topic of web pages and UI toolkit I was writing about a few lines earlier.&lt;/p&gt;
&lt;h2&gt;Animation&lt;/h2&gt;
&lt;p&gt;I already mentioned motion. It is important enough that browsers and UI toolkits went from a simple "draw each element directly into the pixels of the window" model to embedding a compositor and/or relying on the window manager's compositor to accelerate moving things around. In my opinion, not taking motion/animation into account is one of the biggest mistakes a new graphics API design can make in he context of UIs (and in many other use cases). Frame N+1 is usually very similar to frame N, and taking advantage of this is key to get good performance and battery usage in rich and interactive experiences. There are different ways in which two frames can be similar. For example a few elements could be added, or all elements could exist in the two frames with different positions. For some APIs the latter might be considered as being two totally different scenes because all elements have changed, for other APIs that retain the structure of the scene it could just be thought of as the same frame with a different array of animation parameters. Whether the latter is superior to the former really depends on what you think the common use cases will be what is worth optimizing for.
WebRender treats updates with several levels of priority. Scrolling for example &lt;em&gt;must&lt;/em&gt; be able to operate at 60 frames per second, some larger changes to the structure of the scene can be more expensive to operate and are being carried asynchronously to ensure scrolling remains smooth. This is one of the many solutions to the common problem of having to deal with operations that could blow the frame budget. Another way could be to allow expensive work to be done asynchronously by users of the API prior to submitting rendering instructions. In any case I think that it is important to identify these bottlenecks and design the system in a way that prevents them from hurting frame rate.&lt;/p&gt;
&lt;p&gt;In term of API, WebRender is much higher level than a traditional canvas-like API. Instead of building a single frame by submitting drawing commands, consumers of the API build a retained representation made of nested "display lists", and several frames will be rendered from this representation when animated properties of these display lists change (for example scrolling, or other types of animations). By squinting really hard one might see the display list building API as a sort of canvas-like API that builds a scene instead of an image, with an added notion of animated properties. But the display list building API itself doesn't have the generalist and flexible graphics API look of a Cairo or a Skia, instead focusing on describing positioned CSS primitives.&lt;/p&gt;
&lt;h2&gt;Wrapping up&lt;/h2&gt;
&lt;p&gt;At this point my plan was to delve into how WebRender approaches rendering on the GPU in more details and explain in what ways it fundamentally differs from Firefox's previous approach, but I already wrote too many words for a single post. To be honest, I think that WebRender already has the potential to fill the UI rendering niche. Some useful features are missing (for example a full software fallback), but these features are wanted in the long term anyway, so better add them (pull requests are welcome!) than try to replicate the colossal amount of effort that already went into the project.&lt;/p&gt;
&lt;p&gt;Let this post be about me trying to convince you that rendering UIs comes with very specific design constraints and requirements, and that other niches which I failed to talk about would benefit from very different solutions. Whenever I have time to sit down and write another post I'll try to explain what I think would be a good direction for an hypothetical low-level crate focused on path rendering on the GPU with an eye for complex and dynamic scenes. Something very different in goal and scope from WebRender (and in some ways complementary). My hope is that I can stir some of the potential "Let's get together and make a 2d graphics crate" vibe towards that vision.&lt;/p&gt;</content></entry><entry><title>RustFest Paris - Part 2 - Path rendering challenges</title><link href="https://nical.github.io/posts/rustfest-paris-02.html" rel="alternate"></link><published>2018-06-19T00:00:00+02:00</published><updated>2018-06-19T00:00:00+02:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2018-06-19:/posts/rustfest-paris-02.html</id><summary type="html">&lt;p&gt;This is the second part of a series about the talk I gave at &lt;a href="https://paris.rustfest.eu/"&gt;RustFest Paris&lt;/a&gt; about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt;, a crate that helps you render vector graphics on the GPU in Rust.&lt;/p&gt;
&lt;p&gt;The recordings can be found &lt;a href="https://app.media.ccc.de/v/rustfest18-7-vector_graphics_rendering_on_the_gpu_in_rust_with_lyon"&gt;here&lt;/a&gt; or on &lt;a href="https://www.youtube.com/watch?v=2Ng5kpDirDI&amp;amp;list=PL85XCvVPmGQgdqz9kz6qH3SI_hp7Zb4s1&amp;amp;index=7"&gt;YouTube&lt;/a&gt; if you prefer.&lt;/p&gt;
&lt;p&gt;Previous episode:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="rustfest-paris-01.html"&gt;Part 1 - Intro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;The problem …&lt;/h1&gt;</summary><content type="html">&lt;p&gt;This is the second part of a series about the talk I gave at &lt;a href="https://paris.rustfest.eu/"&gt;RustFest Paris&lt;/a&gt; about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt;, a crate that helps you render vector graphics on the GPU in Rust.&lt;/p&gt;
&lt;p&gt;The recordings can be found &lt;a href="https://app.media.ccc.de/v/rustfest18-7-vector_graphics_rendering_on_the_gpu_in_rust_with_lyon"&gt;here&lt;/a&gt; or on &lt;a href="https://www.youtube.com/watch?v=2Ng5kpDirDI&amp;amp;list=PL85XCvVPmGQgdqz9kz6qH3SI_hp7Zb4s1&amp;amp;index=7"&gt;YouTube&lt;/a&gt; if you prefer.&lt;/p&gt;
&lt;p&gt;Previous episode:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="rustfest-paris-01.html"&gt;Part 1 - Intro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;The problem&lt;/h1&gt;
&lt;p&gt;Screens tend to have a lot of pixels these days.&lt;/p&gt;
&lt;p&gt;&lt;img alt="screens" src="https://nical.github.io/images/rustfest/screen.svg"&gt;&lt;/p&gt;
&lt;p&gt;To the point that when rendering interesting vector graphics (or rendering anything, really) at a high resolution, the per-pixel work adds up and becomes a real challenge for the CPU to process sequentially. Our goal here is to render complex vector graphics at interactive frame rates (This typically means a 16ms budget per frame) and we'd obviously like to have some processing power left to do other things.&lt;/p&gt;
&lt;h1&gt;Filling paths on the CPU&lt;/h1&gt;
&lt;p&gt;I am going to use the term "rasterization" and "rasterizer" quite a bit in this post. &lt;a href="https://en.wikipedia.org/wiki/Rasterisation"&gt;Rasterization&lt;/a&gt;, in a nutshell, is the action of turning vector graphics into raster graphics. In other words it's taking vector graphics and rendering them into pixels. I'll focus on filling paths which is probably the most common primitive, but it's not the only thing vector graphics are made of.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What's the deal with GPUs, anyway? I have a beefy CPU, isn't that enough?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Because images are usually laid out in memory row by row in a contiguous buffer, it's ideal to fill shapes from top to bottom, row after row to maximize cache locality of memory accesses and help the CPU's prefetcher.
So it comes without surprise that most path filling implementations use &lt;a href="https://en.wikipedia.org/wiki/Sweep_line_algorithm"&gt;sweep-line algorithms&lt;/a&gt;. The general idea is to start with a list of the path's edges sorted from top to bottom. Imagine an imaginary line (the sweep-line) that traverses the output image a row of pixels at a time. We maintain another list, this one containing the edges that intersect the current row, sorted from left to right (let's call them active edges). During the traversal we use the first sorted list to know which edges to add to the active edge list and when. For each row we go through the active edge list to figure out where to start and stop filling pixels, as well as what to do with pixels that are partially covered.&lt;/p&gt;
&lt;p&gt;&lt;img alt="sweep line" src="https://nical.github.io/images/rustfest/sweepline.gif"&gt;&lt;/p&gt;
&lt;p&gt;There are variations around this algorithm. For example some implementations run the algorithm in a single pass while others will first generate a data structure that represents the spans of pixels to fill and then fill the pixels in a second pass.&lt;/p&gt;
&lt;p&gt;Sweep-lines are very useful when dealing with a lot of different geometry problems (2D and 3D alike) I think that I'll come back to what I like so much about them in another post (maybe in part 3).&lt;/p&gt;
&lt;p&gt;For now if you are interested in knowing more about this stuff I recommend having a look at &lt;a href="https://searchfox.org/mozilla-central/rev/3737701cfab93ccea04c0e9cab211ad10f931d87/gfx/skia/skia/src/core/SkScan_Path.cpp#106"&gt;Skia's scanline rasterization code&lt;/a&gt;, or &lt;a href="http://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/raster/ftraster.c?id=af585ad4fec965fa85f5d61c759f3bc940936de4#n2652"&gt;Freetype's&lt;/a&gt;. The coding style is different but the overall principle is the same. Oh and since this blog post is written in the context of rustfest, you can check &lt;a href="https://github.com/redox-os/rusttype/blob/master/src/rasterizer.rs"&gt;rusttype's rasterizer&lt;/a&gt; out too, it's implemented in rust.&lt;/p&gt;
&lt;p&gt;&lt;img alt="scanline fill" src="https://nical.github.io/images/rustfest/raster.svg"&gt;&lt;/p&gt;
&lt;p&gt;There is another approach worth mentioning implemented in &lt;a href="https://medium.com/@raphlinus/inside-the-fastest-font-renderer-in-the-world-75ae5270c445"&gt;font.rs&lt;/a&gt;, which involves rendering information about the outline of the shape in an accumulation buffer and using that as input to fill the shape in a single tightly optimized loop over the destination image. Notable about this approach is the simplicity of the main filling loop. It runs the same logic on all pixels inside and outside of the shape with very few branches which is very efficient on modern CPUs, at the expense of going over pixels that are outside the shape. When rendering very small images this trade-off works wonderfully. When rendering at very large resolutions, having a sparse representation to avoid touching pixels outside of the shape begins paying off.&lt;/p&gt;
&lt;p&gt;This is a good segue into an important point: There is no optimal one-size-fits-all (or should I say, one-fits-all-sizes!) solution.
When filling a small amount of pixels, a lot of time is typically spent computing the anti-aliasing along the edges, while paths that cover lots of pixel tend to put more pressure on memory bandwidth filling the interior.&lt;/p&gt;
&lt;p&gt;With lyon I focused on large paths covering many pixels, and I wouldn't advise using lyon to render very small text. In another post in this series I will talk a bit about &lt;a href="https://github.com/pcwalton/pathfinder"&gt;pathfinder&lt;/a&gt; which implements two algorithms: one for small resolutions (typically text), and one for larger paths.
I think that there is no way around having dedicated implementations if you want to cover both use cases optimally.&lt;/p&gt;
&lt;h1&gt;Overdraw&lt;/h1&gt;
&lt;p&gt;We saw how to figure out which pixels are inside a shape and fill them. From there to a drawing containing hundreds of paths the process is usually to render these paths individually from back to front, so that front-most elements don't get overwritten by the ones behind them.
Simple enough, however this means that for drawings that are built upon many shapes stacked on top of one another like the famous GhostScript tiger, pixels will typically get written to many times. It's quite a shame, because it means that hidden parts add to the rendering cost just as much as the rest even though they do not contribute to the final image.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ghostscript tiger overdraw" src="https://nical.github.io/images/rustfest/tiger-overdraw.svg"&gt;&lt;/p&gt;
&lt;p&gt;The image above gives an idea of the overdraw for the GhostScript tiger. The lighter a pixel is, the more times it is written to with a traditional back to front rendering algorithm.&lt;/p&gt;
&lt;p&gt;Where overdraw really hurts is usually memory bandwidth. Unfortunately hammering memory tends to make every thing else slower as well. The other threads end up sitting around waiting for memory which limits parallelism, and after the algorithm is done running, other code will typically run into cold caches. It is very hard to avoid this cost in the context of rasterizing 2D graphics on the CPU (in the best case scenario we have to touch every pixel at least once which is already quite a lot).
I have to mention a very cool technique that helps a lot here: the "full-scene rasterizer" approach which consists in having a single sweep-line that renders all paths at once and therefore can touch pixels only once. The rumor has it that the Flash runtime has such an implementation. See also &lt;a href="https://github.com/jrmuizel/full-scene-rasterizer/"&gt;Jeff Muizelaar's full-scene rasterizer&lt;/a&gt; which is open-source. This is however quite hard to implement.&lt;/p&gt;
&lt;h1&gt;What about games?&lt;/h1&gt;
&lt;p&gt;So how do games manage to render so much complex content at interactive frame rates?
For a large part the answer is that games almost always use the GPU for graphics tasks. GPU's have been historically designed and optimized specifically for the needs of the games industry. It would be great if we could leverage these hardware level optimizations when working with 2D content.&lt;/p&gt;
&lt;p&gt;Now saying that something's going to be fast because it uses the GPU is certainly not enough. It is very easy to do slow things with a GPU, especially when trying to port CPU code over. Rather than try to adapt a CPU algorithm to the GPU let's try to reformulate our 2D rendering problem in a way that corresponds to the type of inputs GPUs typically get.&lt;/p&gt;
&lt;p&gt;&lt;img alt="3D rendering" src="https://nical.github.io/images/rustfest/3d.svg"&gt;&lt;/p&gt;
&lt;p&gt;The vast majority of 3D content in interactive applications is made of triangle meshes. The GPU has dedicated hardware for dealing with triangles which makes this primitive very appealing for us. Perhaps if we turn vector shapes into flat triangle meshes (conceptually like a 3D mesh with z = 0) we can get somewhere, and that's the direction I took with lyon.
There are other approaches to rendering vector graphics on the GPU. As I mentioned earlier I don't believe in a one-size-fits-all solution, however I am pretty confident about geometry-based approaches (leveraging the triangle rasterizer) for the use cases I care most about.&lt;/p&gt;
&lt;p&gt;Another interesting feature of the GPU's rasterization pipeline is the depth buffer which contains the depth of each pixel in screen-space. This allows games to render opaque objects in any order and reject pixels that are further behind if something closer to the viewer has already been rendered at that location.
This is a convenient trick for correctness but it is also a great tool to reduce memory bandwidth, since by rendering opaque objects front to back, one can minimize the amount of time pixels are written to and greatly reduce memory bandwidth (remember that memory bandwidth was a big issue for CPU rasterization). Transparent objects are then rendered back to front since painting order actually matters for them.&lt;/p&gt;
&lt;p&gt;&lt;img alt="z-buffer" src="https://nical.github.io/images/rustfest/zbuffer.png"&gt;&lt;/p&gt;
&lt;p&gt;The illustration above was not in the rustfest presentation but perhaps it will help understanding what I am getting at with the depth buffer savings. This is a trick we use in WebRender that consists in rendering opaque shapes in front to back order with the depth buffer enabled to avoid touching pixels many times.
The memory bandwidth savings are actually greater than they seem thanks to smart optimizations implemented in the hardware that allow it to quickly discard entire blocks of pixels at a time before computing their color and writing them to memory.&lt;/p&gt;
&lt;h1&gt;Rendering 2D graphics like a 3D game&lt;/h1&gt;
&lt;p&gt;Lyon in it's current state is not a 2D rendering engine. It is mainly a way to take vector graphics primitives such as paths, and turn them into triangle meshes in a format that is straightforward to render on the GPU (but lyon doesn't implement the GPU bits at this point). The process of turning paths into triangle meshes is called &lt;em&gt;tessellation&lt;/em&gt; (some also use the word &lt;em&gt;triangulation&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img alt="Lyon logo as a triangle mesh" src="https://nical.github.io/images/lyon-logo-tessellated.png"&gt;&lt;/p&gt;
&lt;p&gt;If there is a beautiful thing about leveraging the GPU's triangle rasterization pipeline, is that since rendering becomes similar to a video game, we can use the graphics hardware exactly the way it has been meant to be used and benefit from many years of rendering tricks and optimizations from the games industry.&lt;/p&gt;
&lt;p&gt;The front to back depth buffer trick I mentioned earlier is not actually something implemented in lyon. It is just a very common optimization in 3D game engines which applies naturally when rendering paths tessellated using lyon. It is also a technique we use in &lt;a href="https://github.com/servo/webrender"&gt;webrender&lt;/a&gt; to great effects, and (spoiler alert) it's also &lt;a href="https://github.com/pcwalton/pathfinder"&gt;pathfinder&lt;/a&gt;'s most significant optimization for large paths.&lt;/p&gt;
&lt;p&gt;This is only one of the many tricks that we can learn from games. Game developers have come up with interesting approaches to anti-aliasing, various graphics effects, animation, handling thousands of individual objects and many more challenges which we can apply to our own needs.&lt;/p&gt;
&lt;h1&gt;À suivre...&lt;/h1&gt;
&lt;p&gt;This was part two. We had a superficial look at 2D rendering on the CPU and I argued that there are some benefits to picking a games-like approach to rendering on the GPU.
In the next post we will delve into lyon's tessellation algorithm itself.&lt;/p&gt;</content></entry><entry><title>RustFest Paris - Part 1 - Intro</title><link href="https://nical.github.io/posts/rustfest-paris-01.html" rel="alternate"></link><published>2018-06-18T00:00:00+02:00</published><updated>2018-06-18T00:00:00+02:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2018-06-18:/posts/rustfest-paris-01.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;RustFest organizer: "Are you ready?"&lt;/p&gt;
&lt;p&gt;Me: "Almost."&lt;/p&gt;
&lt;p&gt;(reinstalling Xorg on my laptop 20 minutes before the talk because the window manager would not start)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I gave a talk about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt; at &lt;a href="https://paris.rustfest.eu/"&gt;RustFest Paris&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The recordings are already online, so you can watch it &lt;a href="https://app.media.ccc.de/v/rustfest18-7-vector_graphics_rendering_on_the_gpu_in_rust_with_lyon"&gt;here&lt;/a&gt; or on &lt;a href="https://www.youtube.com/watch?v=2Ng5kpDirDI&amp;amp;list=PL85XCvVPmGQgdqz9kz6qH3SI_hp7Zb4s1&amp;amp;index=7"&gt;YouTube&lt;/a&gt; if you prefer …&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;RustFest organizer: "Are you ready?"&lt;/p&gt;
&lt;p&gt;Me: "Almost."&lt;/p&gt;
&lt;p&gt;(reinstalling Xorg on my laptop 20 minutes before the talk because the window manager would not start)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I gave a talk about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt; at &lt;a href="https://paris.rustfest.eu/"&gt;RustFest Paris&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The recordings are already online, so you can watch it &lt;a href="https://app.media.ccc.de/v/rustfest18-7-vector_graphics_rendering_on_the_gpu_in_rust_with_lyon"&gt;here&lt;/a&gt; or on &lt;a href="https://www.youtube.com/watch?v=2Ng5kpDirDI&amp;amp;list=PL85XCvVPmGQgdqz9kz6qH3SI_hp7Zb4s1&amp;amp;index=7"&gt;YouTube&lt;/a&gt; if you prefer.&lt;/p&gt;
&lt;p&gt;&lt;img alt="lets talk about vector graphics svg" src="https://nical.github.io/images/rustfest/intro.svg"&gt;&lt;/p&gt;
&lt;p&gt;Even though I didn't feel super good about the flow of my speech this time around, I think that the talk was well received and the last minute "let's fix my window manager" episode didn't turn into a disaster.&lt;/p&gt;
&lt;p&gt;It motivated me to write a series of short blog posts about the content of the talk, and explain in more details the information which I was delivering in a hurry in the hope that I wouldn't blow up the talk's allocated time slice. Most of the images in this series of posts are slides from the presentation (made in SVG with Inkscape), but there will be additional content too.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="rustfest-paris-01.html"&gt;Part 1 - Intro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="rustfest-paris-02.html"&gt;Part 2 - Path rendering challenges&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 3 - Lyon's path tessellation algorithm&lt;/li&gt;
&lt;li&gt;Part 4 - Other GPU rendering approaches.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post is the introduction of the talk, wherein I introduce vector graphics and try to get the audience somewhat excited about it. Things will get technical in the follow-up posts.&lt;/p&gt;
&lt;h1&gt;RustFest&lt;/h1&gt;
&lt;p&gt;Before I delve into the talk, I'd like to thank the organizers for their great work on RustFest. I can only begin to imagine how stressful and exhausting it can be to organize such an event and I believe it paid off. I had a great time and I believe the other attendees did as well.&lt;/p&gt;
&lt;h1&gt;Raster graphics and vector graphics&lt;/h1&gt;
&lt;p&gt;Before I delve into lyon, let's get the terminology straight. Raster graphics is what typically comes to mind when thinking about images: a uniform grid of pixels where the color of each pixel is specified independently. Working with uniform grids has a lot of nice properties, for example having random-access in the content of the image to sample the color at a particular point, and being able to perform complex operations that sort of rely on random access like convolution filters.&lt;/p&gt;
&lt;p&gt;On the other hand raster images force authors to think about the resolution at which content is produced versus resolution at which it is presented (the output resolution of a screen for example), and they don't always happen to line up perfectly. So what happens when a 800x450 pixels image has to fill a 2560x1440 pixels screen? In most cases the image will look either blurrier or pixelated. At high resolutions, raster images occupy a lot of space. Image compression formats (png, jpeg and more modern successors) do their best to mitigate that in clever ways but size remains a limiting factor when dealing with large amounts of high resolution raster images, be it in terms of disk pass, or network bandwidth.&lt;/p&gt;
&lt;p&gt;&lt;img alt="slide raster vs vector" src="https://nical.github.io/images/rustfest/rstr-vctr.svg"&gt;&lt;/p&gt;
&lt;p&gt;Fortunately, specifying 2D content pixel by pixel is not the only choice we have at our disposal. In a lot of cases we can author and distribute not the resulting image but the steps to produce it. In very broad terms this is what I refer to when talking about vector graphics.&lt;/p&gt;
&lt;p&gt;Think of the SVG format which can be produced with Inkscape or illustrator. With vector graphics instead of specifying a grid of pixel colors you deal in terms of squares, circles, shapes, polygons, bézier curves, which you can fill and stroke with different types of patterns such as solid colors and gradients. Of course these shapes will eventually get rasterized into a raster image since that's what your screen understands, but the description of vector graphics allows to a great extent to be resolution-independent and happens to be very compact (since specifying a red square requires a small amount of data no matter how many pixels this square will eventually cover).&lt;/p&gt;
&lt;p&gt;Beyond SVG, I consider HTML/CSS to be a vector graphics format, since it is built around the idea of describing how to display 2D content rather than specifying each pixel individually.&lt;/p&gt;
&lt;p&gt;The little shape in the image above doesn't look like much but add many more and you can end up with complex drawings like the famous GhostScript tiger which inevitably appears in any presentation on the topic of vector graphics.&lt;/p&gt;
&lt;p&gt;&lt;img alt="tiger" src="https://nical.github.io/images/rustfest/tiger.svg"&gt;&lt;/p&gt;
&lt;h1&gt;Vector graphics everywhere&lt;/h1&gt;
&lt;p&gt;Today graphical applications all make use of vector graphics. Fonts are almost always described with vector formats, user interfaces, just like web pages need to be described in a way that adapts to various layouts and resolutions, a problem that vector graphics lends itself to addressing naturally.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ui slide" src="https://nical.github.io/images/rustfest/ui.svg"&gt;&lt;/p&gt;
&lt;p&gt;Using a vector format to describe maps avoids spending a lot of network bandwidth on all of these pixels and lets you zoom in and out of a map without seeing a blurry mess (unless the application is unable to render the map at interactive frame rate and choses to show you a scaled version of the previous frame while it renders the new one).&lt;/p&gt;
&lt;p&gt;&lt;img alt="maps" src="https://nical.github.io/images/rustfest/map.svg"&gt;&lt;/p&gt;
&lt;p&gt;Using vector graphics in games can be useful as well. Today, 3D and 2D games come with gigabytes of assets, a huge part of it being fairly high resolution textures. This can be very inconvenient when attempting to distribute games over the network or even just fitting the game alongside the other installed apps in a relatively small drive.
Some games could also take advantage of the resolution-independence to present content at different scales for gameplay purposes or to enhance the story telling.&lt;/p&gt;
&lt;p&gt;&lt;img alt="rpg" src="https://nical.github.io/images/rustfest/rpg.svg"&gt;&lt;/p&gt;
&lt;h1&gt;Vector graphics at 60 frames per seconds&lt;/h1&gt;
&lt;p&gt;Turns out that rendering a screen-full of complex vector graphics at an interactive frame rate is challenging. Whether it is on a laptop or a phone, Screens tend to have a &lt;em&gt;lot&lt;/em&gt; of pixels. Filling this many pixels with interesting content means a fair amount of arithmetic, and involves a lot of memory accesses. To make things worse, the drawing model for 2D content is typically based on the &lt;a href="https://en.wikipedia.org/wiki/Painter%27s_algorithm"&gt;painter's algorithm&lt;/a&gt; which consists in drawing back to front, and this content is usually built upon many overlapping layers. Take a closer look at the tiger above to see what I mean. pixels tend to be written to many times (this is called overdraw), which amplifies the cost of rendering at a high resolution.&lt;/p&gt;
&lt;p&gt;&lt;img alt="screens" src="https://nical.github.io/images/rustfest/screen.svg"&gt;&lt;/p&gt;
&lt;p&gt;As a result of that a lot of applications tend to consider rendering complex vector graphics to be too expensive for high frequency updates and either bake 2D content into textures before releasing the product (a lot of games do that) or architect their rendering tech around hiding this cost, for example by rendering to intermediate surfaces at a low frequency while these surfaces are composited to the screen at a higher frequency, which allows some types of animations stay at a solid 60fps (web browsers in particular do this).&lt;/p&gt;
&lt;h1&gt;À suivre...&lt;/h1&gt;
&lt;p&gt;That's it for part one. In the next post we'll look at how games approach the problem of redrawing the entire screen with complex content at interactive frame rates. We'll see that we can take advantage of these solutions and apply them to rendering 2D vector graphics as well.&lt;/p&gt;</content></entry><entry><title>Introduction to lyon: 2D vector graphics rendering on the GPU in rust</title><link href="https://nical.github.io/posts/lyon-intro.html" rel="alternate"></link><published>2018-01-22T00:00:00+01:00</published><updated>2018-01-22T00:00:00+01:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2018-01-22:/posts/lyon-intro.html</id><summary type="html">&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nical/lyon"&gt;Lyon&lt;/a&gt; is a side-project that I have been working on for quite a while. The goal is to play with rendering 2D vector graphics on the GPU, and it's been a lot of fun so far. I haven't talked a lot about it online (except for a couple of reddit …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nical/lyon"&gt;Lyon&lt;/a&gt; is a side-project that I have been working on for quite a while. The goal is to play with rendering 2D vector graphics on the GPU, and it's been a lot of fun so far. I haven't talked a lot about it online (except for a couple of reddit threads a year or two ago) so I figured it would be a good topic to get this blog started.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The logo" src="https://nical.github.io/images/lyon-logo.svg"&gt;&lt;/p&gt;
&lt;p&gt;In this post I'll talk very briefly about tessellators (lyon's biggest feature) and show a few code snippets to illustrate some of the things you can do with lyon today.&lt;/p&gt;
&lt;h2&gt;Tessellation&lt;/h2&gt;
&lt;p&gt;Path tessellation (or triangulation), in a nutshell, is taking a path (for example a &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Path2D/Path2D"&gt;canvas&lt;/a&gt; or &lt;a href="https://www.w3.org/TR/SVG/paths.html#PathData"&gt;SVG&lt;/a&gt; path) and approximating it with a set of triangles (like the way we usually represent 3d models but in 2d). While the output of the tessellator is customizable, lyon is pretty much designed for generating vertex and index buffers, which anyone working with low level graphics APIs should be familiar with. As a result we obtain geometry in a format that is very easy to work with on the GPU using the same techniques used for 3D graphics.&lt;/p&gt;
&lt;p&gt;&lt;img alt="tessellated shape" src="https://nical.github.io/images/lyon-logo-tessellated.png"&gt;&lt;/p&gt;
&lt;h2&gt;Monotone decomposition&lt;/h2&gt;
&lt;p&gt;So how do we go about tessellating a path? The three most common algorithms are &lt;a href="https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf"&gt;ear-clipping&lt;/a&gt;, &lt;a href="http://www0.cs.ucl.ac.uk/staff/m.slater/Teaching/CG/1997-98/Solutions/Trap/"&gt;trapezoidal decomposition&lt;/a&gt; and monotone decomposition. In lyon I went for the latter.&lt;/p&gt;
&lt;p&gt;Traditionally this algorithm is performed in three passes over the geometry:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first step is to partition the shape in non-self-intersecting shapes (usually using the &lt;a href="https://en.wikipedia.org/wiki/Bentley%E2%80%93Ottmann_algorithm"&gt;Bentley-Ottmann algorithm&lt;/a&gt;),&lt;/li&gt;
&lt;li&gt;then partition these into y-monotone shapes,&lt;/li&gt;
&lt;li&gt;and finally tessellate these y-monotone shapes into triangles.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I want to come back to this in greater details in another post, but I'll just mention here that lyon's fill tessellator is a bit different from the typical implementation of monotone tessellation in the way it represents paths, and runs the steps above in single pass instead of three. Diverging from the traditional implementations seems to pay off since some &lt;a href="https://github.com/nical/lyon/blob/53b6eb48f6c01e1ff8cf6c0ce4010c9019d63e39/bench/tess/src/main.rs#L154"&gt;early measurements&lt;/a&gt; show lyon to be a bit more than twice as fast as &lt;a href="https://github.com/memononen/libtess2"&gt;libtess2&lt;/a&gt;. Take this with a grain of salt, I do need to measure a much wider range of test cases before I can boast about anything, but it's encouraging and there are still a lot of low hanging fruits on the performance side of things.&lt;/p&gt;
&lt;h2&gt;Let's look at some code&lt;/h2&gt;
&lt;p&gt;The easiest way to show off some of what lyon can do for you is to look at some code snippets:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;crate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;math&lt;/span&gt;::&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;path&lt;/span&gt;::&lt;span class="n"&gt;default&lt;/span&gt;::&lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;::&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;tessellation&lt;/span&gt;::&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Build a Path.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;move_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quadratic_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cubic_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Let&amp;#39;s use our own custom vertex type instead of the default one.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cp"&gt;#[derive(Copy, Clone, Debug)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;MyVertex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;: &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;normal&lt;/span&gt;: &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Will contain the result of the tessellation.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;VertexBuffers&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tessellator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FillTessellator&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// Compute the tessellation.&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;tessellator&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tessellate_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path_iter&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;FillOptions&lt;/span&gt;::&lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BuffersBuilder&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;: &lt;span class="nc"&gt;FillVertex&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;MyVertex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;: &lt;span class="nc"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_array&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="n"&gt;normal&lt;/span&gt;: &lt;span class="nc"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_array&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// The tessellated geometry is ready to be uploaded to the GPU.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; -- {} vertices {} indices&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertices&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;indices&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Et voilà! With a fairly small amount of code you can create a path and generate the vertex/index buffers that you will be able to easily render on the GPU with glium, gfx-rs, vulkano, OpenGL, or what have you.&lt;/p&gt;
&lt;p&gt;From there to pixels on your screen, it can be very simple or very complicated, that's really up to your rendering engine. You can have a look at &lt;a href="https://github.com/nical/lyon/tree/master/examples"&gt;the examples&lt;/a&gt; in the repository to get an idea. Lyon doesn't provide a renderering engine (yet), although it is something that I want to explore eventually.&lt;/p&gt;
&lt;h2&gt;What else is there in lyon?&lt;/h2&gt;
&lt;p&gt;Lyon's fill tessellator is by far where most of the work went so far. But there are a bunch of other goodies too. There is a stroke tessellator that supports most SVG stroke properties (line caps, joins, etc.), and some specialized fill and stroke tessellators for common/simpler shapes (circles, rounded rectangles, convex polygons, polylines etc.).&lt;/p&gt;
&lt;p&gt;Lyon is split into a few crates, in a way that is transparent for people who use the main crate, but helps with taming compile times and makes it possible for people to hand-pick certain features with minimal dependencies if they wish to.&lt;/p&gt;
&lt;h3&gt;lyon::geom&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_geom"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_geom"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_geom"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_geom/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lyon's &lt;a href="https://docs.rs/lyon_geom"&gt;geom&lt;/a&gt; module implements a lot of fun math for curve and line segments in 2D (splitting, flattening, intersecting, measuring, etc.) on top of euclid.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;curve&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;QuadraticBezierSegment&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ctrl&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;curve&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;intersection&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;curve&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_intersections&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;curve&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flattened_for_each&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Approximates the curve with a sequence of line segments such&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// that the approximation is never more than 0.01 away from the&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// theoretical curve.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;approximation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you only need this and like minimal dependencies, just do &lt;code&gt;extern crate lyon_geom;&lt;/code&gt; instead of &lt;code&gt;use lyon::geom;&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;lyon::path&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_path"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_path"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_path"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_path/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lyon's &lt;a href="https://docs.rs/lyon_path"&gt;path&lt;/a&gt; module contains path-related data structures and algorithms.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;::&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// The default builder, it supports segments, bézier curves and arcs in&lt;/span&gt;
&lt;span class="c1"&gt;// absolute coordinates&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;move_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quadratc_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// This builder offers the full set of SVG path commands, and translates&lt;/span&gt;
&lt;span class="c1"&gt;// them into absolute coordinates since the default path data structure&lt;/span&gt;
&lt;span class="c1"&gt;// doesn&amp;#39;t support relative coordinates.&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;with_svg&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;move_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;relative_line_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;10.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;smooth_relative_cubic_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// This one automatically flattens the path (approximates curves with&lt;/span&gt;
&lt;span class="c1"&gt;// a sequence of line_to commands) using 0.01 as tolerance threshold&lt;/span&gt;
&lt;span class="c1"&gt;// to build the approximation.&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;flattened&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;move_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cubic_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;path_iter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;PathEvent&lt;/span&gt;::&lt;span class="n"&gt;MoveTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/*...*/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;PathEvent&lt;/span&gt;::&lt;span class="n"&gt;LineTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/*...*/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;PathEvent&lt;/span&gt;::&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/*...*/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;panic&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;unexpected curve segment {:?}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// These can be composed, you get the idea...&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;with_svg&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;flattened&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// While the builder adapters APIs provide &amp;quot;push&amp;quot;-style conversions&lt;/span&gt;
&lt;span class="c1"&gt;// between various path formats, the same kind of operations are&lt;/span&gt;
&lt;span class="c1"&gt;// provided in a &amp;quot;pull&amp;quot;-style API with iterator adapters from the&lt;/span&gt;
&lt;span class="c1"&gt;// lyon::path::iterator module.&lt;/span&gt;

&lt;span class="c1"&gt;// This path stores some curves, and the events are flattened on the&lt;/span&gt;
&lt;span class="c1"&gt;// fly by the iterator.&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path_iter&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;flattened&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Place some dots at a regular interval along a path.&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;RegularPattern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt;: &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;: &lt;span class="nc"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_tangent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_distance&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;dots&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;interval&lt;/span&gt;: &lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// Place dots 3.0 appart from one another.&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;start_offset&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path_iter&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;flattened&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;walk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start_offset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I would like to evolve this crate into a sort of swiss-army-knife of path manipulations, similar to the features &lt;a href="https://github.com/paperjs/paper.js/"&gt;paperjs&lt;/a&gt; offers, for example applying boolean operations to paths, computing convex hulls, etc.&lt;/p&gt;
&lt;p&gt;Like before, if you only want to play with paths without tessellating themyou can do &lt;code&gt;extern crate lyon_path;&lt;/code&gt; instead of &lt;code&gt;use lyon::path;&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;lyon::svg&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_svg"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_svg"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_svg"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_svg/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This module reexports the (very good) &lt;a href="https://docs.rs/svgparser"&gt;svgparser crate&lt;/a&gt; and uses it to provide a simple to build a path from an SVG path syntax:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;with_svg&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;svg&lt;/span&gt;::&lt;span class="n"&gt;path_utils&lt;/span&gt;::&lt;span class="n"&gt;build_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;svg_builder&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;M 0 0 L 10 0 L 10 10 L 0 10 z&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;lyon_tess2&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_extra"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_tess2"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_extra"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_tess2/badge.svg"&gt;&lt;/a&gt; -&lt;/p&gt;
&lt;p&gt;The lyon_tess2 crate is a very recent addition. It provides an alternative fill tessellator that wraps the &lt;a href="https://github.com/memononen/libtess2"&gt;libtess2&lt;/a&gt; C library. I use it mostly to have something to compare lyon against, but as the two tessellators don't have the exact same feature set it can be useful to others as well.&lt;/p&gt;
&lt;h3&gt;The command-line app&lt;/h3&gt;
&lt;p&gt;The repository contains command-line application that you can use to tessellate SVG paths in your favorite terminal, render paths, flattend paths, fuzz the tessellators, find bugs, generate reduced test-cases, and maybe soon make coffee. The app could be used, for example as a tool in an art building pipeline for a game engine. It's definitely great for debugging lyon.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lyon/cli/ $ cargo run --  show -i ../assets/logo.path --fill --stroke --tolerance &lt;span class="m"&gt;0&lt;/span&gt;.01
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="screenshot" src="https://nical.github.io/images/lyon-cli-screenshot.png"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lyon/cli/ $ cargo run --  tessellate &lt;span class="s2"&gt;&amp;quot;M 0 0 L 1 0 L 1 1 L 0 1 Z&amp;quot;&lt;/span&gt; --fill
vertices: &lt;span class="o"&gt;[(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;, &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;, &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;, &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;, &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)]&lt;/span&gt;
indices: &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;, &lt;span class="m"&gt;0&lt;/span&gt;, &lt;span class="m"&gt;2&lt;/span&gt;, &lt;span class="m"&gt;1&lt;/span&gt;, &lt;span class="m"&gt;2&lt;/span&gt;, &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;What's next?&lt;/h2&gt;
&lt;p&gt;There are many things that I'd like to see happening in the project, and it will certainly take a long time for most of them to concretise as time is a scarse resource.&lt;/p&gt;
&lt;h3&gt;Polish the fill tessellator&lt;/h3&gt;
&lt;p&gt;The fill tessellator has grown into something that I am quite happy about. It is not perfect, I definitely want to keep improving its robustness and finish implementing for the non-zero &lt;a href="https://www.w3.org/TR/SVG/painting.html#FillRuleProperty"&gt;fill rule&lt;/a&gt;, but it's already robust enough for many use cases. For example &lt;a href="http://ggez.rs"&gt;ggez&lt;/a&gt;, the rust crate to make good games easily, uses it to render polygons, and I know that a few other projects use it to make games and even to render openstreetmaps data.&lt;/p&gt;
&lt;h3&gt;A new tessellator&lt;/h3&gt;
&lt;p&gt;I want to start working on a new fill tessellator optimized for curves and able to produce a resolution-independent tessellation, probably using trapezoidal partioning like &lt;a href="https://github.com/pcwalton/pathfinder"&gt;pathfinder&lt;/a&gt;. The new tessellator will work best with curves but will not be as good for polygons as a monotone tessellator, so the current tessellator is definitely here to stay.&lt;/p&gt;
&lt;h3&gt;A high level renderer on top of lyon&lt;/h3&gt;
&lt;p&gt;This was my initial goal when the project started forever ago. As it turns out tessellation was a fascinatingly and hard topic and I decided to focus on it for a while. It would be great to play with a 2D renderer for interactive content (like games and &lt;a href="https://beesandbombs.tumblr.com/"&gt;creative coding&lt;/a&gt;) and see what a 2D API designed for your GPU would look like (as opposed to GPU backends for APIs that were designed for CPUs a decade or two ago for static content, which is the state of most 2D APIs these days).&lt;/p&gt;
&lt;h3&gt;Documentation&lt;/h3&gt;
&lt;p&gt;There was a big documentation push a year ago and it was worth it. Let's do this again.&lt;/p&gt;
&lt;h3&gt;Maybe the next feature is going to be your idea&lt;/h3&gt;
&lt;p&gt;Or even your next pull request, Who knows?&lt;/p&gt;
&lt;h2&gt;Big thanks to all contributors&lt;/h2&gt;
&lt;p&gt;Now is a good time to underline that I didn't do all of this work alone. I want to thank again all the &lt;a href="https://github.com/nical/lyon/wiki/Contributors#contributors"&gt;awesome individuals&lt;/a&gt; who submitted contributions, big and small, to the project. This project is too large for a single person's spare time, and seeing people come and give a hand is the most rewarding and motivating thing. Also thanks a lot to everyone who is using lyon and reporting bugs!&lt;/p&gt;
&lt;p&gt;Want to join the fun? Check out the &lt;a href="https://github.com/nical/lyon/blob/master/CONTRIBUTING.md"&gt;contribution guidelines&lt;/a&gt;, get started on the &lt;a href="https://github.com/nical/lyon/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22"&gt;easier issues&lt;/a&gt;, and don't hesitate to ask any question on &lt;a href="https://gitter.im/lyon-rs/Lobby"&gt;gitter&lt;/a&gt; or irc in #rust-gamedev.
I want this project to be as fun and welcoming as possible and I would love it to be more of a team effort than a one man show. If you are running into issues contribting, &lt;a href="https://github.com/nical/lyon/issues/32"&gt;let me know&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="lyon stickers photo" src="https://nical.github.io/images/lyon-stickers.jpg"&gt;&lt;/p&gt;
&lt;p&gt;There are lyon stickers which is the ultimate proof that the project is cool.&lt;/p&gt;</content></entry></feed>