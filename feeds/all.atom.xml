<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Eight million pixels and counting</title><link href="https://nical.github.io/" rel="alternate"></link><link href="https://nical.github.io/feeds/all.atom.xml" rel="self"></link><id>https://nical.github.io/</id><updated>2021-02-04T00:00:00+01:00</updated><entry><title>Improving texture atlas allocation in WebRender</title><link href="https://nical.github.io/posts/etagere.html" rel="alternate"></link><published>2021-02-04T00:00:00+01:00</published><updated>2021-02-04T00:00:00+01:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2021-02-04:/posts/etagere.html</id><summary type="html">&lt;p&gt;Lately I have been working on improving texture atlas allocation in WebRender. It isn't an outstanding technical feat, but the journey towards achieving this goal was quite pleasant. &lt;/p&gt;
&lt;p&gt;This is a longer version of the piece I published in the &lt;a href="https://mozillagfx.wordpress.com/2021/02/04/improving-texture-atlas-allocation-in-webrender/"&gt;mozilla gfx team blog&lt;/a&gt; where I focus on the atlas …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Lately I have been working on improving texture atlas allocation in WebRender. It isn't an outstanding technical feat, but the journey towards achieving this goal was quite pleasant. &lt;/p&gt;
&lt;p&gt;This is a longer version of the piece I published in the &lt;a href="https://mozillagfx.wordpress.com/2021/02/04/improving-texture-atlas-allocation-in-webrender/"&gt;mozilla gfx team blog&lt;/a&gt; where I focus on the atlas allocation algorithms. In this one I'll go into more details about the process and methodology behind these improvements.&lt;/p&gt;
&lt;p&gt;The first part is about the making of guillotiere, a crate that I first released in March 2019. In the second part we'll have a look at more recent work building upon what I did with guillotiere, to improve texture memory usage in WebRender/Firefox.&lt;/p&gt;
&lt;h1&gt;Texture atlas allocation&lt;/h1&gt;
&lt;p&gt;In order to submit work to the GPU efficiently, WebRender groups as many drawing primitives as it can into what we call batches. A batch is submitted to the GPU as a single drawing command and has a few constraints. for example a batch can only reference a fixed set of resources (such as GPU buffers and textures). So in order to group as many drawing primitives as possible in a single batch we need to place as many drawing parameters as possible in few resources. When rendering text, WebRender pre-renders the glyphs before compositing them on the screen  so this means packing as many pre-rendered glyphs as possible into a single texture, and the same applies for rendering images and various other things.&lt;/p&gt;
&lt;p&gt;For a moment let's simplify the case of images and text and assume that it is the same problem: input images (rectangles) of various rectangular sizes that we need to pack into a larger rectangle. This is the job of the texture atlas allocator. Another common name for this is rectangle bin packing.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Atlas allocation" src="https://nical.github.io/images/atlas/atlas-allocation.svg"&gt;&lt;/p&gt;
&lt;p&gt;Many in game and web development are used to packing many images into fewer assets. In most cases this can be achieved at build time Which means that the texture atlas allocator only needs to find a good layout for a fixed set of rectangles without supporting dynamic deallocation and allocation within the atlas at run time. I call this "static" atlas allocation as opposed to "dynamic" atlas allocation.&lt;/p&gt;
&lt;p&gt;There's a lot more literature out there about static than dynamic atlas allocation. I recommend reading &lt;a href="http://pds25.egloos.com/pds/201504/21/98/RectangleBinPack.pdf"&gt;&lt;em&gt;A thousand ways to pack the bin&lt;/em&gt;&lt;/a&gt; which is a very good survey of various static packing algorithms. Dynamic atlas allocation is unfortunately more difficult to implement while keeping good run-time performance. WebRender needs to maintain texture atlases into which items are added and removed over time. In other words we don't have a way around needing dynamic atlas allocation.&lt;/p&gt;
&lt;h1&gt;Chapter 1&lt;/h1&gt;
&lt;p&gt;A while back, WebRender had a naive implementation of the guillotine algorithm (explained in &lt;a href="http://pds25.egloos.com/pds/201504/21/98/RectangleBinPack.pdf"&gt;&lt;em&gt;A thousand ways to pack the bin&lt;/em&gt;&lt;/a&gt;). This algorithm strikes a good compromise between packing quality and implementation complexity.
The main idea behind it can be explained simply: "Maintain a list of free rectangles, find one that can hold your allocation, split the requested allocation size out of it, creating up to two additional rectangles that are added back to the free list.". There is subtlety in which free rectangle to choose and how to split it, but the overall, the algorithm is built upon reassuringly understandable concepts.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Guillotine allocation steps" src="https://nical.github.io/images/atlas/guillotine-alloc.svg"&gt;&lt;/p&gt;
&lt;p&gt;Deallocation could simply consist of adding the deallocated rectangle back to the free list, but without some way to merge back neighbor free rectangles, the atlas would quickly get into a fragmented stated with a lot of small free rectangles and can't allocate larger ones anymore.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Fragmented state" src="https://nical.github.io/images/atlas/fragmented.svg"&gt;&lt;/p&gt;
&lt;p&gt;To address that, WebRender's implementation would regularly do a O(n²) complexity search to find and merge neighbor free rectangles, which was very slow when dealing with thousands of items. Eventually we stopped using the  guillotine allocator in systems that needed support for deallocation, replacing it with a very simple slab allocator which I'll get back to later in this post.&lt;/p&gt;
&lt;p&gt;I wasn't satisfied with moving to a worse allocator because of the run-time defragmentation issue, so as a side project I wrote a guillotine allocator that tracks rectangle splits in a tree in order to find and merge neighbor free rectangle in constant instead of quadratic time. I published it in the &lt;a href="https://crates.io/crates/guillotiere"&gt;guillotiere&lt;/a&gt; crate. I wrote about how it works in details in &lt;a href="https://docs.rs/guillotiere/0.6.0/guillotiere/struct.AtlasAllocator.html"&gt;the documentation&lt;/a&gt; so I won't go over it here. I'm quite happy about how it turned out, although I haven't pushed to use it in WebRender, mostly because I wanted to first see evidence that it would help and I already had evidence that many other things needed to be worked on.&lt;/p&gt;
&lt;h2&gt;Visualizing program state using SVG&lt;/h2&gt;
&lt;p&gt;guillotiere lets you dump a visualization of the atlas in SVG format.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Guillotine allocation visualization" src="https://nical.github.io/images/atlas/guillotine-example-1.svg"&gt;&lt;/p&gt;
&lt;p&gt;The image above shows the state of the atlas after a few allocations. Allocated space is represented in light blue while free space is in dark gray. It is much easier to work with than a list of coordinates in plain text. It was handy when developing and tuning the algorithm, but also when using it in other projects. While looking at the visual representation of the state animate you quickly develop an intuition of how the algorithm unfolds Concepts that are hard to explain in written form sometimes just "make sense" visually.&lt;/p&gt;
&lt;p&gt;Dumping visual representations in a .svg file is not only a powerful tool when exploring problem some spaces, it is also surprisingly simple to do. SVG is a straightforward XML type of format which is annoying to type by hand but effortless to generate with very simple helpers. Here is how it looks using a tiny helper crate called &lt;a href="https://crates.io/crates/svg_fmt"&gt;svg_fmt&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;svg_fmt&lt;/span&gt;::&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;::&lt;span class="n"&gt;fs&lt;/span&gt;::&lt;span class="n"&gt;File&lt;/span&gt;::&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tmp.svg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Need this at the beginning of the file. Set the size of the drawable area to 800x600.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;writeln&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;{}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BeginSvg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;: &lt;span class="mf"&gt;800.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;: &lt;span class="mf"&gt;600.0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Draw a rectangle.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;writeln&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="s"&gt;r#&amp;quot;    {}&amp;quot;#&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;rectangle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;10.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;10.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;100.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;200.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fill&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rgb&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stroke&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Stroke&lt;/span&gt;::&lt;span class="n"&gt;Color&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;black&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Draw some text at position 100.0 100.0&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;writeln&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;{}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;100.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;100.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Some text!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_string&lt;/span&gt;&lt;span class="p"&gt;()));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Need this at the end.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;writeln&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;{}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;EndSvg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;So many useful visualizations can be easily built out of simple colored rectangles and text and there's other primitives provided by svg_fmt. Rectangles were all I needed in guillotiere.&lt;/p&gt;
&lt;p&gt;You can look at &lt;a href="https://github.com/nical/rust_debug/blob/492600cac47f64bcadaf9ad037ed64c5fecc8e63/svg_fmt/src/svg.rs"&gt;how simple the svg_fmt code is&lt;/a&gt;. It has become a dependency to most of the things I've worked on lately, including WebRender which uses it to dump visualizations of texture atlases and the render graph.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Render graph visualization" src="https://nical.github.io/images/atlas/rendergraph.svg"&gt;&lt;/p&gt;
&lt;p&gt;My hope by now is that if you are working on problems that can be represented in 2D space, I've managed to convince you of how easily you can supplement or break free of reading text in your debugger/terminal. If anything, just &lt;code&gt;println!(r#"&amp;lt;rect x="{}" y="{}" width="{}" height="{}" fill:rgb(100,0,0)" /&amp;gt;""#, x, y, w, h);&lt;/code&gt; your way into looking at your algorithms unfolding.&lt;/p&gt;
&lt;h2&gt;Making/testing/debugging a small rust crate&lt;/h2&gt;
&lt;p&gt;I had a great time writing guillotiere for several reasons. The problem itself had some nice properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It's a well defined problem with simple input and output data. As a result it is very easy to write unit tests and fuzz the code.&lt;/li&gt;
&lt;li&gt;No nebulous design space for fancy abstractions. A retained state, query a size in, get a rectangle out. Simple.&lt;/li&gt;
&lt;li&gt;Can be implemented in its own library outside of a big rendering engine, and enjoy fast compile/debug iterations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It was the Rust programming language and ecosystem that really made it a such pleasant journey.&lt;/p&gt;
&lt;p&gt;Bootstrapping a simple library, creating unit tests, adding dependencies is simple and effortless in Rust. This alone is a huge time saver for me compared to when I would do this sort of thing in C++ (I can only hope that the situation has improved in C++ since). Fellow Rust developers are pretty used to that so let's move on.&lt;/p&gt;
&lt;p&gt;I quickly wrote a simple command-line application to interactively play with the packing algorithm.
The application deserializes the state of the atlas from a file, execute a command (for example allocation or deallocation) and serializes back into the file (using the .ron file format). In addition, the command-line application could dump a visualization of the atlas in SVG.&lt;/p&gt;
&lt;p&gt;The command-line app was put together very quickly thanks to fantastic pieces of the Rust ecosystem:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://crates.io/crates/serde"&gt;serde&lt;/a&gt; for serialization/deserialzation,&lt;/li&gt;
&lt;li&gt;&lt;a href="https://crates.io/crates/ron"&gt;ron&lt;/a&gt; providing a nice and readable serialized file format,&lt;/li&gt;
&lt;li&gt;and &lt;a href="https://crates.io/crates/clap"&gt;clap&lt;/a&gt; for parsing command-line arguments.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Put together, this gave me an interactive playground to test the algorithm. Playing around in a terminal would look like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ guillotiere init &lt;span class="m"&gt;1024&lt;/span&gt; &lt;span class="m"&gt;1024&lt;/span&gt;
$ guillotiere allocate &lt;span class="m"&gt;16&lt;/span&gt; &lt;span class="m"&gt;32&lt;/span&gt;
Allocated rectangle r1 of size 16x32 at origin &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;, &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
$ guillotiere allocate &lt;span class="m"&gt;200&lt;/span&gt; &lt;span class="m"&gt;100&lt;/span&gt; --svg &lt;span class="m"&gt;01&lt;/span&gt;.svg
Allocated rectangle r2 of size 200x100 at origin &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;16&lt;/span&gt;, &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
$ guillotiere deallocate r1 --svg &lt;span class="m"&gt;02&lt;/span&gt;.svg

etc...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;At any time in that sequence of commands I can open the &lt;code&gt;atlas.ron&lt;/code&gt; file and read the state of the atlas as if I was in a debugger, can also copy it around to save the state in a way that almost feels as powerful as using &lt;a href="https://rr-project.org/"&gt;record-and-replay debugging&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Fuzzing&lt;/h2&gt;
&lt;p&gt;I mentioned fuzzing earlier. &lt;a href="https://github.com/rust-fuzz/cargo-fuzz"&gt;Cargo fuzz&lt;/a&gt; is a joy and I really recommend using it whenever possible. It's very easy to setup, I wouldn't necessarily run it on every push, but every once in a while to find some bugs and/or get a bit of confidence about the robustness of your code. It's great. It has plenty of well written &lt;a href="https://rust-fuzz.github.io/book/"&gt;documentation&lt;/a&gt; so I won't go into details here. I'll just mention that it's a very well made piece of Rust's ecosystem that contributes to the greatness of the whole in my opinion.&lt;/p&gt;
&lt;h1&gt;Chapter 2&lt;/h1&gt;
&lt;p&gt;Fast forward the end of 2020. Ah 2020.&lt;/p&gt;
&lt;p&gt;I was investigating further improvements to draw call batching and texture upload overhead which are big performance bottlenecks on low end Intel GPUs, especially on Windows.&lt;/p&gt;
&lt;p&gt;Gathering some statistics about what causes new batches to be generated shows that it is often happening when multiple primitives use the same shader but are reading from different textures. Interesting. If we were able to pack more image into fewer textures we could improve the likelihood of primitives reading the same texture and therefore generate less batches and reduce the driver overhead.&lt;/p&gt;
&lt;p&gt;In addition, being able to pack more images into less texture memory means we can afford to keep more of them on the GPU, evict images less often from the atlas (it is an LRU cache), and hopefully reduce the likelihood of having to re-upload images and glyphs. Texture uploads are terribly expensive on some configurations so avoiding them whenever we can is worthwhile.&lt;/p&gt;
&lt;p&gt;Of course there is a balancing act. If we keep items longer in the cache we may not be able to pack them into fewer textures. If we pack items into few textures we may have to put pressure on the cache, not letting us keep items longer. The ideal solution will somewhere between the two. In any case, being able to pack more items in a given amount of texture space is very beneficial so more than a year after guillotiere's first release on crates.io, I had some data suggesting that better texture atlases was worth spending time on.&lt;/p&gt;
&lt;p&gt;I was not quite at a point where I knew for sure whether integrating guillotiere into WebRender would be the right thing to do (I did have strong suspicions that it would be an improvement but I wanted to validate them first), and guillotiere might not be the best solution for WebRender's particular workloads.&lt;/p&gt;
&lt;h2&gt;Methodology&lt;/h2&gt;
&lt;p&gt;In order to iterate quickly, I wanted to test algorithms outside of Firefox. I made a small Rust command-line program very similar to the one I had made for guillotiere (read: mostly copy-pasted from it) which I could use to replay recorded real-world atlas allocation workloads, recorded via some instrumentation in Firefox.&lt;/p&gt;
&lt;p&gt;I ended up with a few scripts to replay the allocations different browsing sessions, that looked like:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
atlas allocate &lt;span class="m"&gt;7&lt;/span&gt; &lt;span class="m"&gt;23&lt;/span&gt; -n &lt;span class="m"&gt;1&lt;/span&gt;
atlas allocate &lt;span class="m"&gt;10&lt;/span&gt; &lt;span class="m"&gt;20&lt;/span&gt; -n &lt;span class="m"&gt;2&lt;/span&gt;
atlas allocate &lt;span class="m"&gt;15&lt;/span&gt; &lt;span class="m"&gt;22&lt;/span&gt; -n &lt;span class="m"&gt;3&lt;/span&gt;
atlas allocate &lt;span class="m"&gt;14&lt;/span&gt; &lt;span class="m"&gt;23&lt;/span&gt; -n &lt;span class="m"&gt;4&lt;/span&gt;
atlas allocate &lt;span class="m"&gt;19&lt;/span&gt; &lt;span class="m"&gt;22&lt;/span&gt; -n &lt;span class="m"&gt;5&lt;/span&gt;
atlas allocate &lt;span class="m"&gt;5&lt;/span&gt; &lt;span class="m"&gt;22&lt;/span&gt; -n &lt;span class="m"&gt;6&lt;/span&gt;
atlas allocate &lt;span class="m"&gt;15&lt;/span&gt; &lt;span class="m"&gt;15&lt;/span&gt; -n &lt;span class="m"&gt;7&lt;/span&gt;
atlas deallocate &lt;span class="m"&gt;2&lt;/span&gt;
atlas deallocate &lt;span class="m"&gt;5&lt;/span&gt;

atlas svg snapshot-01.svg

atlas allocate &lt;span class="m"&gt;15&lt;/span&gt; &lt;span class="m"&gt;15&lt;/span&gt; -n &lt;span class="m"&gt;8&lt;/span&gt;
&lt;span class="c1"&gt;# ... Tens of thousands of lines like the above.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;I would first run the program to set some initial parameters, for example &lt;code&gt;atlas init tiled 2048 2048&lt;/code&gt;, then run the scripts to replay some workloads. The scripts dumps some snapshots in SVG format at various fixed points. So that I could compare how different algorithms look at the same steps of the the same workloads.&lt;/p&gt;
&lt;p&gt;The program would also record various stats such as size distributions, the highest number of allocated items at any given step or the amount of wasted space coming from the allocation strategy.&lt;/p&gt;
&lt;h2&gt;The slab allocator&lt;/h2&gt;
&lt;p&gt;What replaced WebRender's guillotine allocator in the texture cache was a very simple one based on fixed power-of-two square slabs, with a few special-cased rectangular slab sizes for tall and narrow items to avoid wasting too much space. The texture is split into 512 by 512 regions, each region is split into a grid of slabs with a fixed slab size per region. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Slab allocation visualization" src="https://nical.github.io/images/atlas/slab-example-1.svg"&gt;&lt;/p&gt;
&lt;p&gt;The image above shows the slab allocator in action on the image cache for a real browsing session, replayed in my little tool.&lt;/p&gt;
&lt;p&gt;This is a very simple scheme with very fast allocation and deallocation, however it tends to waste a lot of texture memory. For example allocating an 8x10 pixels glyph occupies a 16x16 slot, wasting more than twice the requested space. Ouch!
In addition, since regions can allocate a single slab size, space can be wasted by having a region with few allocations because the slab size happens to be uncommon.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Slab allocation wasted space" src="https://nical.github.io/images/atlas/slab-wasted-space.svg"&gt;&lt;/p&gt;
&lt;p&gt;Before replacing the slab allocator, I wanted to see if simple improvements could be enough. It wouldn't be wise to replace simple code with something with more complicated without seeing how far we can push the simple solution.&lt;/p&gt;
&lt;h2&gt;Improvements to the slab allocator&lt;/h2&gt;
&lt;p&gt;Images and glyphs used to be cached in the same textures. However we render images and glyphs with different shaders, so currently they can never be in the same rendering batches. Having a separate set of textures for images and glyphs therefore doesn't regress batching. On the other hand it provides with a few opportunities.
Not mixing images and glyphs means the glyph textures get more room for glyphs which reduces the number of textures containing glyphs overall. In other words, less chances to break batches. The same naturally applies to images. This is of course at the expense of allocating more textures on average, but it is a good trade-off for us and we are about to compensate the memory increase by using tighter packing.&lt;/p&gt;
&lt;p&gt;In addition, glyphs and images are different types of workloads: we usually have a few hundred images of all sizes in the cache, while we have thousands of glyphs most of which have similar small sizes. Separating them allows us to introduce some simple workload-specific optimizations.&lt;/p&gt;
&lt;p&gt;The first optimization came from noticing that glyphs are almost never larger than 128px. Having more and smaller regions, reduces the amount of atlas space that is wasted by partially empty regions, and allows us to hold more slab sizes at a given time so I reduced the region size from 512x512 to 128x128 in the glyph atlases. In the unlikely event that a glyph is larger than 128x128, it will go into the image atlas.&lt;/p&gt;
&lt;p&gt;Next, I recorded the allocations and deallocations browsing different pages, gathered some statistics about most common glyph sizes and noticed that on a low-dpi screen, a quarter of the glyphs would land in a 16x16 slab but would have fit in a 8x16 slab. In latin scripts at least, glyphs are usually taller than wide. Adding 8x16 and 16x32 slab sizes that take advantage of this helps a &lt;em&gt;lot&lt;/em&gt;.
I could have further optimized specific slab sizes by looking at the data I had collected, but the more slab sizes I would add, the higher the risk of regressing different workloads. This problem is called over-fitting. I don't know enough about the many non-latin scripts used around the world to trust that my testing workloads were representative enough, so I decided that I should stick to safe bets (such as "glyphs are usually small") and avoid piling up optimizations that might penalize some languages. Adding two slab sizes was fine (and worth it!) but I wouldn't add ten more of them.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Slab allocator improvements" src="https://nical.github.io/images/atlas/slab-improvements.svg"&gt;&lt;/p&gt;
&lt;p&gt;The image above shows the same (real-world) workload applied to both the original and improved slab allocators.&lt;/p&gt;
&lt;p&gt;At this point, I had nice improvements to glyph allocation using the slab allocator, but was starting to get a firm intuition that I was going to hit a ceiling trying to improve it further.&lt;/p&gt;
&lt;h2&gt;Shelf packing allocators&lt;/h2&gt;
&lt;p&gt;I experimented with two algorithms derived from the shelf packing allocation strategy, both of them released in the Rust crate &lt;a href="https://crates.io/crates/etagere"&gt;etagere&lt;/a&gt;. The general idea behind shelf packing  is to separate the 2-dimensional allocation problem into a 1D vertical allocator for the shelves and within each shelf, 1D horizontal allocation for the items.
The atlas is initialized with no shelf. When allocating an item, we first find the shelf that is the best fit for the item vertically, if there is none or the best fit wastes too much vertical space, we add a shelf. Once we have found or added a suitable shelf, an horizontal slice of it is used to host the allocation.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Shelf packing" src="https://nical.github.io/images/atlas/shelf-packing.svg"&gt;&lt;/p&gt;
&lt;p&gt;At a glance we can see that this scheme is likely to provide much better packing than the slab allocator. For one, items are tightly packed horizontally within the shelves. That alone saves a lot of space compared to the power-of-two slab widths. Most of the waste happens vertically, between an item and the top of its shelf. How much the shelf allocator wastes vertically depends on how the shelve heights are chosen. Since we aren't constrained to power-of-two size, we can also do much better than the slab allocator vertically.&lt;/p&gt;
&lt;h3&gt;The bucketed shelf allocator&lt;/h3&gt;
&lt;p&gt;The first shelf allocator I implemented was inspired from Mapbox's &lt;a href="https://github.com/mapbox/shelf-pack/"&gt;shelf-pack&lt;/a&gt; allocator written in JavaScript. It has an interesting bucketing strategy: items are accumulated into fixed size "buckets" that behave like a small bump allocators. Shelves are divided into a certain number of buckets and buckets are only freed when all elements are freed (via reference counting). The trade-off here is to keep atlas space occupied for longer in order to reduce the CPU cost of allocating and deallocating. Only the top-most shelf is removed when empty so consecutive empty shelves in the middle aren't merged until they become the top-most shelves, which can cause a bit of vertical fragmentation for long running sessions. When the atlas is full of (potentially empty) shelves the chance that a new item is too tall to fit into one of the existing shelves depends on how common the item height is. Glyphs tend to be of similar (small) heights so it works  out well enough.&lt;/p&gt;
&lt;p&gt;I added very limited support for merging neighbor empty shelves. When an allocation fails, the atlas iterates over the shelves and checks if there is a sequence of empty shelves that in total would be able to fit the requested allocation. If so, the first shelf of the sequence becomes the size of the sum, and the other shelves are squashed to zero height. It sounds like a band aid (it is) but the code is simple and it is working within the constraints that make the rest of the allocator very simple and fast. It's only a limited form of support for merging empty shelves but it was an improvement for workloads that contain both small and large items.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Shelf packing" src="https://nical.github.io/images/atlas/glyphs-bucketed-shelf.svg"&gt;&lt;/p&gt;
&lt;p&gt;The image above was generated using the command-line tool with one of the glyph cache workloads. We see fewer wide boxes rather than many thin boxes because the allocator internally doesn't keep track of each item rectangle individually, so we only see buckets filling up instead.&lt;/p&gt;
&lt;p&gt;This allocator worked quite well for the glyph texture (unsurprisingly, as Mapbox's implementation this was inspired from is used with their glyph cache). The bucketing strategy was problematic, however, with large images. The relative cost of keeping allocated space longer was higher with larger items. Especially with long running sessions, this allocator was good candidate for the glyph cache but not for the image cache.&lt;/p&gt;
&lt;h3&gt;The simple shelf allocator&lt;/h3&gt;
&lt;p&gt;The guillotine allocator was working rather well with images. I was close to just using it for the image cache and move on. However, having spent a lot of time looking at various allocations patterns, my intuition was that we could do better. Again, this is largely thanks to being able to visualize the algorithm via these neat little SVG dumps.&lt;/p&gt;
&lt;p&gt;It motivated experimenting with a second shelf allocator. This one is conceptually even simpler: A basic vertical 1D allocator for shelves with a basic horizontal 1D allocator per shelf. Since all items are managed individually, they are deallocated eagerly which is the main advantage over the bucketed implementation. It is also why it is slower than the bucketed allocator, especially when the number of items is high. This allocator also has full support for merging/splitting empty shelves wherever they are in the atlas.&lt;/p&gt;
&lt;p&gt;&lt;img alt="A glyph packing workload" src="https://nical.github.io/images/atlas/glyphs-shelf.svg"&gt;&lt;/p&gt;
&lt;p&gt;The image above was generated using the command-line tool with the same glyph cache workload as the previous image. This allocator tracks each individual item so we get a more precise picture. &lt;/p&gt;
&lt;p&gt;Unlike the Bucketed allocator, this one worked very well for the image workloads. For short sessions (visiting only a handful of web pages) it was not as tightly packed as the guillotine allocator, but after browsing for longer period of time, it had a tendency to better deal with fragmentation.&lt;/p&gt;
&lt;p&gt;&lt;img alt="An image packing workload" src="https://nical.github.io/images/atlas/img-shelf.svg"&gt;&lt;/p&gt;
&lt;p&gt;The image above was generated using the command-line tool with an image cache workload. Notice how different the image workloads look (using the same texture size), with much fewer items and a mix of large and small items sizes.&lt;/p&gt;
&lt;p&gt;The implementation is very simple, scanning shelves linearly and then within the selected shelf another linear scan to find a spot for the allocation. I expected performance to scale somewhat poorly with high number of glyphs (we are dealing in the thousands of glyphs which arguably isn't that high), but the performance hit wasn't as bad I had anticipated, probably helped by mostly cache friendly underlying data-structure.&lt;/p&gt;
&lt;h3&gt;A few other experiments&lt;/h3&gt;
&lt;p&gt;For both allocators I implemented the ability to split the atlas into a fixed number of columns. Adding columns means more (smaller) shelves in the atlas, which further reduces vertical fragmentation issues, at the cost of wasting some space at the end of the shelves. Good results were obtained on 2048 by 2048 atlases with two columns. You can see in the previous two images that the shelf allocator was configured to use two columns.&lt;/p&gt;
&lt;p&gt;The shelf allocators support arranging items in vertical shelves instead of horizontal ones. It can have an impact depending on the type of workload, for example if there is more variation in width than height for the requested allocations. As far as my testing went, it did not make a significant difference with workloads recorded in Firefox so I kept the default horizontal shelves.&lt;/p&gt;
&lt;p&gt;The allocators also support enforcing specific alignments in x and y (effectively, rounding up the size of allocated items to a multiple of the x and y alignment). This introduces a bit of wasted space but avoids leaving tiny holes smaller than the alignment size in the atlas. Some platforms also require a certain alignment for various texture transfer operations so it is useful to have this knob to tweak at our disposal. In the Firefox integration, we use different alignments for each type of atlas, favoring small alignments for atlases that mostly contain small items to keep the relative wasted space small.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;&lt;img alt="A few more texture atlases for fun" src="https://nical.github.io/images/atlas/various-atlases.svg"&gt;&lt;/p&gt;
&lt;p&gt;The guillotine allocator is the best at keeping track of all available space and can provide the best packing of all algorithms I tried. The shelf allocators waste a bit of space by simplifying the arrangement into shelves, and the slab allocator wastes a lot of space for the sake of simplicity. On the other hand the guillotine allocator is the slowest when dealing with multiple thousands of items and can suffer from fragmentations in some of the workloads I recorded. Overall the best compromise was the simple shelf allocator which I ended up using in Firefox for both glyph and image textures in the cache (in both cases configured to have two columns per texture). The bucketed allocator is still a very reasonable option for glyphs and we could switch to it in the future if we feel we should trade some packing efficiency for allocation/deallocation performance.&lt;/p&gt;
&lt;p&gt;In other parts of WebRender, for short lived atlases (a single frame), the guillotine allocation algorithm is used.&lt;/p&gt;
&lt;p&gt;These observations are mostly workload-dependent, though. Workloads are rarely completely random so results may vary.&lt;/p&gt;
&lt;p&gt;There are other algorithms I could have explored (and maybe will someday, who knows), but I had found a satisfying compromise between simplicity, packing efficiency, and performance. I wasn't aiming for state of the art packing efficiency. Simplicity was a very important parameter and whatever solutions I came up with would have to be simple enough to ship it in a web browser without risks.&lt;/p&gt;
&lt;p&gt;To recap, my goals were to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;allow packing more texture cache items into fewer textures,&lt;/li&gt;
&lt;li&gt;reduce the amount of texture allocation/deallocation churn,&lt;/li&gt;
&lt;li&gt;avoid increasing GPU memory usage, and if possible reduce it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This was achieved by improving atlas packing to the point that we rarely have to allocate multiple textures for each item type (provided the amount of pixels that need to be cached which depends on what the page has to show on screen at any given time can possibly fit in a texture of course).&lt;/p&gt;
&lt;p&gt;The results look pretty good so far. Before the changes in Firefox, glyphs would often be spread over a number of textures after having visited a couple of websites, Currently the cache eviction is set so that we rarely need more than than one or two textures with the new allocator, and with some future tuning of the cache eviction logic I am confident that we can get glyphs to fit consistently into a single texture. For images, the shelf allocator is pretty big win as well. what fit into five textures now fits into two or three.&lt;/p&gt;
&lt;p&gt;Today this translates into fewer draw calls and less CPU-to-GPU transfers which has a noticeable impact on performance on low end Intel GPUs, in addition to reducing GPU memory usage.&lt;/p&gt;
&lt;p&gt;The slab allocator improvements landed in &lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1674443"&gt;bug 1674443&lt;/a&gt; and shipped in Firefox 85, while the shelf allocator integration work went in &lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1679751"&gt;bug 1679751&lt;/a&gt; and will make it hit the release channel in Firefox 86. The interesting parts of this work are packaged in a couple of rust crates under permissive MIT OR Apache-2.0 license:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nical/guillotiere"&gt;guillotiere&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/guillotiere"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/guillotiere"&gt;&lt;/a&gt; &lt;a href="https://docs.rs/guillotiere"&gt;&lt;img alt="doc" src="https://docs.rs/guillotiere/badge.svg"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nical/etagere"&gt;etagere&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/etagere"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/etagere"&gt;&lt;/a&gt; &lt;a href="https://docs.rs/etagere"&gt;&lt;img alt="doc" src="https://docs.rs/etagere/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The hacky tool I put together to experiment with all of this can be found &lt;a href="https://github.com/nical/texture-atlas"&gt;on github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I am quite happy with the Firefox improvements. I am also very pleased with the whole journey, with its visual explorations, data-driven decisions and effortless testing, debugging and even fuzzing.&lt;/p&gt;</content><category term="webrender, rust"></category></entry><entry><title>A new tessellator</title><link href="https://nical.github.io/posts/new-tessellator.html" rel="alternate"></link><published>2019-12-26T00:00:00+01:00</published><updated>2019-12-26T00:00:00+01:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2019-12-26:/posts/new-tessellator.html</id><summary type="html">&lt;p&gt;This post is about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt;, a rust crate to tessellate arbitrary 2D shapes into triangle meshes that can be easily rendered on the GPU.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;About a year ago, in the &lt;a href="https://nical.github.io/posts/lyon-2018.html"&gt;lyon in 2018 post&lt;/a&gt; on this blog, I mentioned that I was working on a complete rewrite of lyon's central …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This post is about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt;, a rust crate to tessellate arbitrary 2D shapes into triangle meshes that can be easily rendered on the GPU.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;About a year ago, in the &lt;a href="https://nical.github.io/posts/lyon-2018.html"&gt;lyon in 2018 post&lt;/a&gt; on this blog, I mentioned that I was working on a complete rewrite of lyon's central piece, the &lt;a href="https://docs.rs/lyon_tessellation/0.15.0/lyon_tessellation/struct.FillTessellator.html"&gt;fill tessellator&lt;/a&gt;. I have been working on this for quite a bit. The work-in-progress &lt;a href="https://github.com/nical/lyon/pull/334"&gt;pull request&lt;/a&gt; was created in February 2018. Almost two years in the making, this work made it in version &lt;a href="https://crates.io/crates/lyon/0.15.0"&gt;&lt;code&gt;0.15&lt;/code&gt;&lt;/a&gt;, the project's biggest release ever.&lt;/p&gt;
&lt;p&gt;It was a lot of work. Too much work. Fortunately, I am pretty happy about the result.&lt;/p&gt;
&lt;h1&gt;Motivation&lt;/h1&gt;
&lt;p&gt;So, why put so much effort in rewriting all of this?&lt;/p&gt;
&lt;h2&gt;Robustness&lt;/h2&gt;
&lt;p&gt;The fill tessellator was pretty robust, but not 100% bullet-proof. There's a built-in fuzzer in the test suite that could run for many hours before finding a shape that breaks the tessellator, but would always eventually stumble upon unrecoverable state and panic or return an error. The fuzzer wasn't the only entity to find issues. a few users reported some panics using the tessellator. Some of these reports were easy to address, some were very hard, and it almost always boiled down to precision loss introduced by arithmetic operations performed when detecting and handling self-intersecting geometry. The tessellator's algorithm had been built around a simplified mental model where arithmetic is precise, and key geometric properties could always be taken for granted. Long story short, there were some rare but very hard to fix bugs that required rethinking core parts of the algorithm.&lt;/p&gt;
&lt;p&gt;The new tessellator embraces the idea that no matter how hard we try to avoid it, some floating point precision issues will eventually cause some invalid states to appear. Instead of relying on this to be prevented the new algorithm is built around being able to detect and recover from these issues.&lt;/p&gt;
&lt;p&gt;This is done by splitting each iteration in two phases: the &lt;em&gt;scan phase&lt;/em&gt; has most of the interesting logic of the algorithm, but doesn't perform any mutation. Instead it records changes that will be applied int the &lt;em&gt;update phase&lt;/em&gt; which only performs the mutations.&lt;/p&gt;
&lt;p&gt;Errors can be detected during the scan phase. Sometimes these errors imply that some of the analysis performed during the scan is invalid (for example due to incorrect edge ordering), but it doesn't matter because the scan phase hasn't committed any mutation, so we can bail out of it, do our best to sanitize our initial state and run the iteration again.&lt;/p&gt;
&lt;p&gt;In overly-simplified Rust pseudo-code, the main loop looks somewhat like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tesselator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;algorithm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-&amp;gt; &lt;span class="nc"&gt;TessellationResult&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;iteration&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iterations&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// Invalid states can be detected during the &amp;quot;analysis&amp;quot; or &amp;quot;scan&amp;quot; phase.&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;updates&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scan_phase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iteration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nb"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;updates&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;updates&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nb"&gt;Err&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="c1"&gt;// Something is wrong, recover from it before trying again.&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recover_from_error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="c1"&gt;// Return an error if we fail the second time.&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scan_phase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iteration&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// Internal mutations can only happen here.&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update_phase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;updates&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This doesn't sound like much but it is a major shift in how the algorithm is organized. This alone required a rewrite and it paid off.&lt;/p&gt;
&lt;p&gt;Another key aspect of the new design was avoiding to rely on prior events when information can be reconstructed locally. In other words try hard not to have invalid state accumulate and contaminate subsequent steps of the algorithm.&lt;/p&gt;
&lt;p&gt;I am sure that bugs will be found as it always goes with any new non-trivial piece of code. It'll be wise to take the claims I made about robustness with a grain of salt until the code has had a chance to be used in more places and pass the test of time. I have let the fuzzer run on 4 of cores of a beefy desktop for about 48 hours and it didn't find any panic. That's already a lot more robust than the previous tessellator, at least with the family of bugs that the fuzzer is good at finding. I am also confident that it will be much easier to fix upcoming issues with the new algorithm.&lt;/p&gt;
&lt;h2&gt;Getting rid of fixed-point numbers&lt;/h2&gt;
&lt;p&gt;In an effort to make reasoning about precision easier, the old tessellator had moved most (but not all) of its geometric calculations to a fixed point number representation. It helped at first but in the long run it turned out to be a mistake. A mistake that was impossible to come back from after months of adjusting thresholds and other knobs to paper over precision issues that still existed. Fixed-point numbers, while providing a somewhat consistent precision loss that I had an easier time wrapping my head around, still lost precision and didn't solve the root of the issue. They helped with the easy problems and got in the way of fixing the hardest ones.&lt;/p&gt;
&lt;p&gt;In addition, fixed point numbers came with two major drawbacks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The range of numbers that could represented inside the tessellator was greatly reduced in comparison with 32 bit floats. My initial feeling was that users wouldn't often need to work with coordinates larger than &lt;code&gt;32767.0&lt;/code&gt;, but that assumption proved to be wrong. While it was possible to work around the issue by scaling the path down and scaling the output mesh back up, it was far from a satisfying answer.&lt;/li&gt;
&lt;li&gt;The vertices generated by the tessellator were almost but not quite the same as the points of the input shapes, due to being converted to fixed-point and back to float.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The new tessellator internally works with 32 bit floating point numbers and the positions from the original path are now unmodified in the output.&lt;/p&gt;
&lt;h2&gt;Custom vertex attributes&lt;/h2&gt;
&lt;p&gt;In order to achieve certain effects it is often desirable to be able to associate extra attributes per-vertex attributes, for example color, texture coordinates, bone weights, etc.&lt;/p&gt;
&lt;p&gt;This has been lyon's most requested feature, but a tricky one to get right. On the surface it seems simple: give all path endpoints their own ID and present these IDs when building the vertices during tessellation. However the tessellator occasionally has to create new vertices that do not correspond to existing endpoints of the input path, for example when handling self-intersections or when flattening bézier curves.&lt;/p&gt;
&lt;p&gt;To address this, the tessellator keeps track for each vertex of all of the edges that it belongs to and where on these edges. This information can be cumbersome to consume, so a concept of interpolated attributes was built on top of it. The idea is that an array of floating point numbers can be associated to each of the input path's endpoints and passed to the geometry builder when generating vertices. When the source of a vertex is more complex than a single endpoint, the tessellator interpolates the values automatically.&lt;/p&gt;
&lt;p&gt;Find out more about this in the &lt;a href="https://docs.rs/lyon_tessellation/0.15.0/lyon_tessellation/struct.FillTessellator.html#vertex-sources"&gt;documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The same mechanism was also added to the stroke tessellator.&lt;/p&gt;
&lt;h2&gt;Fill rules&lt;/h2&gt;
&lt;p&gt;The old tessellator was pretty much written for the even-odd &lt;a href="https://www.w3.org/TR/SVG/painting.html#WindingRule"&gt;fill rule&lt;/a&gt; and adding more fill rules turned out to be difficult in hindsight. The new tessellator's algorithms was designed with this in mind and currently supports non-zero and even-odd. More fill rules can easily be added, but these two are the only ones in SVG standard.&lt;/p&gt;
&lt;p&gt;The image below shows the same path, filled with the even-odd (on the left) and non-zero (on the right) fill rules&lt;/p&gt;
&lt;p&gt;&lt;img alt="Fill rules" src="https://nical.github.io/images/lyon-evenodd-nonzero.png"&gt;&lt;/p&gt;
&lt;h2&gt;Other goodies&lt;/h2&gt;
&lt;p&gt;The new tessellator can dynamically chose to traverse the geometry vertically or horizontally. As a rule of thumb it is usually better for performance to do a vertical sweep for shapes that are taller than wide, and do an horizontal sweep for shapes that are wider than tall.&lt;/p&gt;
&lt;p&gt;The image below shows the triangles generated with vertical (on the left) and horizontal (on the right) traversals of the same path.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Vertical and horizontal traversals" src="https://nical.github.io/images/lyon-sweep-v-h.png"&gt;&lt;/p&gt;
&lt;p&gt;I spent a lot of time on the APIs related to building, storing and iterating over paths. This release has types to make working with simple &lt;a href="https://docs.rs/lyon_path/0.15.0/lyon_path/polygon/index.html"&gt;polygons&lt;/a&gt; nicer, as well as utilities to create &lt;a href="https://docs.rs/lyon_path/0.15.0/lyon_path/commands/index.html"&gt;custom path data structures&lt;/a&gt; which work with the tessellators.&lt;/p&gt;
&lt;h1&gt;What's the catch?&lt;/h1&gt;
&lt;p&gt;There are few caveats that I want to mention:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The old fill tessellator was able to provide normals at each vertex. The new tessellator, however, cannot do that. Removing normals allowed a great deal of much needed simplification. I don't think that I will add this feature back. The stroke tessellator still has vertex normals, though.&lt;/li&gt;
&lt;li&gt;The new tessellator is a bit slower than the old one. This is mostly due to not having spent a lot of time profiling and optimizing yet and I am pretty confident that most of the gap can be closed. The new implementation is still about 50% faster than libtess2 (which I consider to be the "industry standard") on the workloads I compared them against (mostly the Rust logo and GhostScript tiger), so it's still pretty decent.&lt;/li&gt;
&lt;li&gt;A lot of APIs have changed. If you've used lyon before it'll still be familiar but updating, while not difficult, is likely to take a bit of effort.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In previous blog posts I mentioned a plan to handle bézier curves directly in the tessellator in order to allow resolution-independent tessellations and handle curves on the GPU (using tessellation or fragment shaders). I had to scope the project down in order to finally get something to shippable and this feature didn't make it. It's possible that I'll revisit it some time in the future, but realistically it will take a long time before I get an ambitious feature such as this one to work, if I ever do.&lt;/p&gt;
&lt;h1&gt;What's next?&lt;/h1&gt;
&lt;p&gt;For a little while, bug fixes and polish, after which I am hoping to tag a symbolic &lt;code&gt;1.0&lt;/code&gt; release some time in 2020. I still have this project of improving the quality of the tessellated geometry (generating less thin triangles) that I would like to get back to, and There are a few algorithms I'd like to play with, like stroke-to-fill conversion and boolean operations.
I would also like to spend some time working &lt;em&gt;with&lt;/em&gt; lyon rather than only &lt;em&gt;on&lt;/em&gt; it, though I don't know yet what will come out of that.&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;I am really happy and proud to finally release the new tessellator. It adds up to an enormous amount of work over the last two years, but I think that it was necessary to take the tessellator from pretty good to really robust and reliable. While uncompromising robustness was the main motivation behind this rewrite, a number of important features were also made possible.&lt;/p&gt;
&lt;p&gt;Although the rewrite wasn't well set up for external contributions, development didn't stop on the master branch! I would like to thank everyone who made contributions to lyon in 2019 and the years before. Also many thanks to everyone who reported bugs, for their time, patience and support.&lt;/p&gt;
&lt;p&gt;This blog does not have a comments section, discussion on &lt;a href="https://www.reddit.com/r/rust/comments/efz5jb/lyon_0150_a_new_tessellator/"&gt;reddit&lt;/a&gt;.&lt;/p&gt;</content><category term="lyon, rust"></category></entry><entry><title>A look at pathfinder</title><link href="https://nical.github.io/posts/a-look-at-pathfinder.html" rel="alternate"></link><published>2019-05-28T00:00:00+02:00</published><updated>2019-05-28T00:00:00+02:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2019-05-28:/posts/a-look-at-pathfinder.html</id><summary type="html">&lt;p&gt;This post is about &lt;a href="https://github.com/pcwalton/pathfinder"&gt;pathfinder&lt;/a&gt;, a GPU vector graphics renderer written in Rust by Patrick Walton as part of his work in the emerging technologies team at Mozilla. While I have followed this work very closely, I have contributed very little code to pathfinder so the credit really goes to …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This post is about &lt;a href="https://github.com/pcwalton/pathfinder"&gt;pathfinder&lt;/a&gt;, a GPU vector graphics renderer written in Rust by Patrick Walton as part of his work in the emerging technologies team at Mozilla. While I have followed this work very closely, I have contributed very little code to pathfinder so the credit really goes to Patrick.&lt;/p&gt;
&lt;p&gt;If you've read other entries on the blog you've heard of &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt;, which helps you with rendering vector graphics on the GPU by turning paths into triangle meshes. Pathfinder takes a completely different approach, so you should ignore everything I have written about lyon's tessellator while reading this post.&lt;/p&gt;
&lt;p&gt;Also, Pathfinder has gone through several complete rewrites each of which going for very different approaches, so information on &lt;a href="https://pcwalton.github.io/2017/02/14/pathfinder.html"&gt;some of Patrick's older blog posts&lt;/a&gt; doesn't apply anymore.&lt;/p&gt;
&lt;p&gt;Pathfinder can be used to render glyph atlases and larger scenes such as SVG paths. The two use cases are handled a bit differently and in this post I will be focusing on the latter.&lt;/p&gt;
&lt;h2&gt;Tiling&lt;/h2&gt;
&lt;p&gt;Pathfinder splits paths into 16x16 pixels tiles. This tiling scheme has the following purposes:
 - Decompose the path which as a whole is a very complex object to render, into may smaller and simpler objects.
 - Use tiles that are completely filled with an opaque pattern for occlusion culling.&lt;/p&gt;
&lt;p&gt;For example let's look at the following simple scene:&lt;/p&gt;
&lt;p&gt;&lt;img alt="A simple scene" src="https://nical.github.io/images/pathfinder/simple-scene.png"&gt;&lt;/p&gt;
&lt;p&gt;And decompose it into tiles:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tiled simple scene" src="https://nical.github.io/images/pathfinder/tiled-simple-scene.png"&gt;&lt;/p&gt;
&lt;p&gt;In the scene, we have a number of opaque tiles that are very simple to render once we have identified that they are fully covered by a path.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tiled simple scene" src="https://nical.github.io/images/pathfinder/opaque-tiles.png"&gt;&lt;/p&gt;
&lt;p&gt;These are simply rendered by submitting a batch of instanced quads.&lt;/p&gt;
&lt;p&gt;A very good property of opaque tiles is that they completely hide what's under them, so we can trivially discard all blue tiles below an opaque green tile since we know it is fully occluded. This massively reduces overdraw in typical SVG drawings.&lt;/p&gt;
&lt;p&gt;The image below gives an idea of the overdraw of the famous GhostScript tiger. The lighter a pixel is, the more times it is written to with a traditional back to front rendering algorithm without occlusion culling.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ghostscript tiger overdraw" src="https://nical.github.io/images/rustfest/tiger-overdraw.svg"&gt;&lt;/p&gt;
&lt;p&gt;Because memory bandwidth is often the bottleneck when rendering vector graphics (especially at high resolutions), this occlusion culling is key to pathfinder's performance.&lt;/p&gt;
&lt;p&gt;Here is a view of the opaque tile pass for the GhostScript tiger in renderdoc:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tiger opaque tiles in renderdoc" src="https://nical.github.io/images/pathfinder/tiger-opaque-tiles.png"&gt;&lt;/p&gt;
&lt;p&gt;The opaque tile pass is very fast because it has zero overdraw and doesn't need any blending.&lt;/p&gt;
&lt;h2&gt;Alpha tiles&lt;/h2&gt;
&lt;p&gt;Back to our simple scene, this leaves us with the partially covered tiles to deal with:&lt;/p&gt;
&lt;p&gt;&lt;img alt="partial tiles of the simple scene" src="https://nical.github.io/images/pathfinder/simple-scene-partial-tiles.png"&gt;&lt;/p&gt;
&lt;p&gt;Opaque tiles are easy. It's good that we were able to detect them and render them with simple instanced quads, it even gives us a crude approximation of the final image, but the real challenge remains to render curves with high quality anti-aliasing.&lt;/p&gt;
&lt;p&gt;I will use the terms &lt;em&gt;alpha tiles&lt;/em&gt; or &lt;em&gt;mask tiles&lt;/em&gt; for tiles that contain edges. These are rendered in two passes. First a mask is generated in a float texture and the mask is used to render the tile on top of the opaque tiles.&lt;/p&gt;
&lt;p&gt;The float texture containing the masks for our simple scene might look something like this:&lt;/p&gt;
&lt;p&gt;&lt;img alt="mask tiles of the simple scene" src="https://nical.github.io/images/pathfinder/simple-scene-mask.png"&gt;&lt;/p&gt;
&lt;h2&gt;Rendering the masks&lt;/h2&gt;
&lt;p&gt;It is very common when dealing with vector graphics to separate the computation of coverage (whether a pixel is in or out of the path) shading (color of the pixel if it is covered).
Stencil-and-cover rendering approaches are textbook examples of this, traditionally rendering triangle fans into the stencil buffer to produce a binary coverage mask (pixels are either in or out of the path). Because this doesn't let you express partial coverage per pixel, anti-aliasing is usually done using multi-sampling.&lt;/p&gt;
&lt;p&gt;Unfortunately, MSAA is quite slow on Intel integrated GPUs. Even on more powerful NVidia and AMD GPUs, MSAA is expensive with high sample counts, so people will rarely ask for more than 8 samples per pixel which provides something far from what I would call high quality anti-aliasing.&lt;/p&gt;
&lt;p&gt;Instead of rendering masks into an integer textures like the stencil buffer, pathfinder renders into a float texture and uses instanced quads instead of building triangle fans along the shape of the path.&lt;/p&gt;
&lt;p&gt;Each edge intersecting a tile is submitted as a quad that corresponds the bounding rectangle of the edge intersected with bounds of the tile and with the lower edge snapped to the bottom of the tile.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tile edge quad" src="https://nical.github.io/images/pathfinder/tile-mask-quad.png"&gt;&lt;/p&gt;
&lt;p&gt;That the shape of these quads might look somewhat arbitrary. Before we can make sense of it we have to look at what this quad actually renders. For each pixel the fragment shader writes 0 if it is fully above the edge, ±1 below the edge, or a value in between corresponding to the coverage of the pixel if it is near the edge. The output value is either positive or negative depending on the winding of the edge.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tile edge quad" src="https://nical.github.io/images/pathfinder/tile-mask-shader.png"&gt;&lt;/p&gt;
&lt;p&gt;The quads are rendered with additive blending, causing the contributions of each edge to accumulate in the tile's mask.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tile edge quad" src="https://nical.github.io/images/pathfinder/mask-coverage.png"&gt;&lt;/p&gt;
&lt;p&gt;Now why did we snap the bottom of the quads to the bottom of the tile?&lt;/p&gt;
&lt;p&gt;In a lot of vector graphics rendering approaches, it helps to imagine that we are casting a ray (usually horizontal) coming from far away and looking at intersections against the path to generate a winding number for each pixel along the ray.&lt;/p&gt;
&lt;p&gt;In pathfinder, the edge quads are equivalent to groups of vertical rays coming from the top of the tile, writing the contribution of a single edge to all pixels below the edge, down to the bottom of the tile. We could have also snapped the top of the quad the top of the tile, but since we don't need to consider pixels above the edge we save a few pixel's worth of work by only stating at the top of the edge's bounding box.&lt;/p&gt;
&lt;p&gt;Rather than only writing the winding number between edges, pathfinder simply writes  the contribution of each edge to all pixels below it, which will give the same result since the contribution of two edges can cancel each other out if our imaginary ray was going in then out of the path before reaching the pixel.&lt;/p&gt;
&lt;p&gt;Note that using vertical rays is purely a matter of convention. Pathfinder could have been written in a way that follows the "horizontal ray coming from the left" analogy by snapping the right side of the quad to the right of the tile.&lt;/p&gt;
&lt;h2&gt;What if the top of a tile starts is already inside of the path ?&lt;/h2&gt;
&lt;p&gt;In the previous illustration we took it from granted that the top of the tile was outside ( initial winding numbers are zeros), but this does not always hold true in practice as any edge above the tile can contribute as well.&lt;/p&gt;
&lt;p&gt;One solution could be to simply include all edges above the tile but for large drawing this can bring a lot of edges. So pathfinder handles this during the tiling phase on the CPU by tracking the winding number at the top of each tile and inserting a minimal amount of extra edges to compensate for the information that is lost by only considering edges inside of the tile.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tile edge quad" src="https://nical.github.io/images/pathfinder/mask-coverage-2.png"&gt;&lt;/p&gt;
&lt;p&gt;On the left side of the image below, the tiger is rendered and the triangles emitted during the compositing pass of the mask tiles are highlighted in yellow. On the right side the same pass is rendered on top of a black background to better see which parts of the drawing end up drawn with mask tiles. The image was produced thanks to renderdoc.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tile edge quad" src="https://nical.github.io/images/pathfinder/tiger-alpha-pass.png"&gt;&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Piecing it all together:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Paths are split into tiles on the CPU.&lt;/li&gt;
&lt;li&gt;Mask tiles are rendered in a float texture on the GPU.&lt;/li&gt;
&lt;li&gt;Solid tiles, which were detected during the tiling phase, are rendered into the destination color target.&lt;/li&gt;
&lt;li&gt;Mask tiles are composited into the color target, reading from the mask tiles that were rendered in the float texture.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The above sequence is what happens under the simplest settings. Pathfinder has the option to start submitting rendering commands while tiling is in progress to hide some of the latency of the tiling phase. There is also the option of tiling paths in parallel using rayon, which provides a nice speedup on computers with more than two physical cores.&lt;/p&gt;
&lt;h2&gt;Rendering strokes&lt;/h2&gt;
&lt;p&gt;Up to this point I only wrote about filling paths, but strokes are also important.
Currently pathfinder simply transforms stroke primitives into fill primitives on the CPU. It works and was a quick way to get things up and running, but it's certainly costly. Rendering strokes without expressing them as fills will be implemented eventually. The strokes can generate mask tiles just like fills. The main difference would be in how these mask tiles are generated. With round line joins and round line caps it's pretty simple. We can use the maximum of the distance to each edge. Other line joins require a bit more work but there is a lot of prior art to follow or get inspiration from.&lt;/p&gt;
&lt;h2&gt;Rendering other types of primitives&lt;/h2&gt;
&lt;p&gt;Pathfinder's tiling scheme has the following nice properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mask tiles can be rendered in any order.&lt;/li&gt;
&lt;li&gt;The "compositing" phase is independent from how the mask tiles were generated.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This means that any kind of rendering primitive (2D distance fields come to mind for example) that can produce tile masks are very easy to integrate into this system without introducing batching issues, while also benefiting from the occlusion culling optimizations.&lt;/p&gt;
&lt;h2&gt;Rendering text&lt;/h2&gt;
&lt;p&gt;To some, pathfinder is better known as a text rasterizer than as a way to render larger vector graphics scenes. Rendering glyphs works the same way except that tiling isn't necessary because glyphs are usually small enough that the occlusion culling would not help at all.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Pathfinder's main takeaways are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A tiling scheme allowing powerful optimizations such as occlusion culling and a very fast opaque tile pass.&lt;/li&gt;
&lt;li&gt;An interesting way to compute coverage by rendering quads into a floating point texture.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The two are actually completely independent and one could use the same tiling approach while rendering tiles in a totally different way for example using multi-sampling instead of computing coverage analytically (There is an open issue about adding an option for that in pathfinder). I really like the composability of this architecture.&lt;/p&gt;
&lt;p&gt;Pathfinder is a very simple, pragmatic, yet fast approach to rendering vector graphics using the GPU. It's not finished, there are many missing features and areas in which it can and will improve. I mentioned rendering strokes, and I think that the performance of the CPU tiling pass could be improved. In its current state it is still a good deal faster at rendering very large and complex SVG drawings than using a CPU rasterizer and uploading the result to a texture.&lt;/p&gt;
&lt;p&gt;I'm hoping to integrate it in WebRender and start using it in Firefox some time this year. This is possible thanks to pathfinder's reliance on very few GPU features (any GPU supporting float textures works with pathfinder).&lt;/p&gt;
&lt;p&gt;Is Pathfinder the fastest GPU vector graphics approach that there is? Probably not. It picks, however, the right trade-offs to be a very good, if not the best, candidate to my knowledge for integration in a web browser with a small rendering team and a very diverse user base (lots of old hardware to support).&lt;/p&gt;
&lt;p&gt;I'll close this post with a few good reads for those who want to further explore different approaches to rendering vector graphics on the GPU:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://raphlinus.github.io/rust/graphics/gpu/2019/05/08/modern-2d.html"&gt;A presentation of Piet-metal&lt;/a&gt; by Raph Levien.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wdobbie.com/post/gpu-text-rendering-with-vector-textures/"&gt;GPU text rendering with vector textures&lt;/a&gt; by Will Dobbie.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://hhoppe.com/ravg.pdf"&gt;Random access vector graphics&lt;/a&gt; paper by Hugues Hoppe and Diego Nehab.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://w3.impa.br/~diego/publications/GanEtAl14.pdf"&gt;Massively parallel vector graphics&lt;/a&gt; paper by Francisco Ganacim, Rodolfo S. Lima, Luiz Henrique de Figueiredo and Diego Nehab which follows up on the random access paper with a different data structure.&lt;/li&gt;
&lt;li&gt;FastUIDraw technical details &lt;a href="https://01.org/fast-ui-draw/blogs/krogovin/2016/fast-ui-draw-technical-details-1"&gt;part 1&lt;/a&gt; and &lt;a href="https://01.org/fast-ui-draw/blogs/krogovin/2016/fast-ui-draw-technical-details-2"&gt;part 2&lt;/a&gt; and &lt;a href="https://www.youtube.com/watch?v=2ryvYS47V0E&amp;amp;feature=youtu.be&amp;amp;t=6h08m23s"&gt;XDC2016 talk&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/@evanwallace/easy-scalable-text-rendering-on-the-gpu-c3f4d782c5ac"&gt;Easy scalable text rendering on the GPU&lt;/a&gt; by Evan Wallace.&lt;/li&gt;
&lt;/ul&gt;</content><category term="pathfinder, rust"></category></entry><entry><title>Lyon in 2018</title><link href="https://nical.github.io/posts/lyon-2018.html" rel="alternate"></link><published>2019-02-17T00:00:00+01:00</published><updated>2019-02-17T00:00:00+01:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2019-02-17:/posts/lyon-2018.html</id><summary type="html">&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;About a year ago I published &lt;a href="https://nical.github.io/posts/lyon-intro.html"&gt;
"Introduction to lyon: 2D vector graphics rendering on the GPU in rust"
&lt;/a&gt; on this blog. Lyon was in version &lt;a href="https://docs.rs/lyon/0.8.8/lyon/"&gt;&lt;code&gt;0.8.8&lt;/code&gt;&lt;/a&gt; back then and I recently published &lt;a href="https://docs.rs/lyon/0.13.0/lyon/"&gt;&lt;code&gt;0.13.0&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In 2018 my activity on the project has varied depending on the time …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;About a year ago I published &lt;a href="https://nical.github.io/posts/lyon-intro.html"&gt;
"Introduction to lyon: 2D vector graphics rendering on the GPU in rust"
&lt;/a&gt; on this blog. Lyon was in version &lt;a href="https://docs.rs/lyon/0.8.8/lyon/"&gt;&lt;code&gt;0.8.8&lt;/code&gt;&lt;/a&gt; back then and I recently published &lt;a href="https://docs.rs/lyon/0.13.0/lyon/"&gt;&lt;code&gt;0.13.0&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In 2018 my activity on the project has varied depending on the time and energy I have had left after work and other activities. As it turns out, working on &lt;a href="http://mozillagfx.wordpress.com/"&gt;getting WebRender shipped in Firefox&lt;/a&gt; is at the same time amazing and very demanding, and what's left of my brain after a good day of work isn't always up to some of the ambitions I have planned for lyon. Fortunately I am not the only one who contributed to the project, and while progress was slow on the most ambitious plans, I did spend some time on smaller features and polish.&lt;/p&gt;
&lt;p&gt;I'll get to these big plans towards the end of this post. In the mean time let's look at some of the highlights of what changed in lyon in 2018.&lt;/p&gt;
&lt;h2&gt;lyon_geom&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_geom"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_geom"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_geom/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I want to start with an epic contribution from &lt;a href="https://github.com/kleintom"&gt;Tom Klein&lt;/a&gt;: The addition of a robust cubic bézier intersection algorithm using fat line clipping. You can read about this journey in the original &lt;a href="https://github.com/nical/lyon/pull/422"&gt;pull request&lt;/a&gt; and &lt;a href="https://github.com/nical/lyon/pull/427"&gt;followup improvements&lt;/a&gt;. Suffice to say, I'm impressed with the quality and rigor of the work Tom put in this feature.&lt;/p&gt;
&lt;p&gt;Tom also &lt;a href="https://github.com/nical/lyon/pull/419"&gt;added&lt;/a&gt; an elliptic arc to cubic bézier approximation (&lt;a href="https://docs.rs/lyon_geom/0.12.2/lyon_geom/arc/struct.Arc.html#method.for_each_cubic_bezier"&gt;doc link&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;There were other additions such as tight bounding rectangle calculation for elliptic arcs, improvements and fixes to the various curve approximation algorithms and a lot of API ergonomic improvements.&lt;/p&gt;
&lt;p&gt;This year has confirmed the trend that a number of people are using lyon_geom without the rest of lyon. The way the lyon crates are separated seems to have paid off in letting people who only want curve math tools get a minimal dependency.&lt;/p&gt;
&lt;h2&gt;lyon_tessellation&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_tessellation"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_tessellation"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_tessellation"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_tessellation/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To me, &lt;a href="https://docs.rs/lyon_tessellation/0.13.0/lyon_tessellation/struct.FillTessellator.html"&gt;the fill tessellator&lt;/a&gt; is the most important piece of the whole project. The majority of the changes to the fill tessellator were bug fixes, almost all of them related to dreadful numerical precision issues when paths have many self-intersections and in particular when a lot of these self-intersections are almost at the same position. This type of paths isn't representative of human generated content but the robustness of the tessellator is important to me and I want to keep improving it.&lt;/p&gt;
&lt;p&gt;As far as API changes are concerned, I added the possibility to chose the type of the generated indices of the vertex/index buffer pairs. Before that, indices were always &lt;code&gt;u16&lt;/code&gt; and some users ran into the limit when generating large amount of geometry with a single path or when tessellating too many paths in the same vertex and index buffer pair. The tessellator now internally works with &lt;code&gt;u32&lt;/code&gt; indices and the convenience &lt;a href="https://docs.rs/lyon_tessellation/0.13.0/lyon_tessellation/struct.BuffersBuilder.html"&gt;&lt;code&gt;BuffersBuilder&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://docs.rs/lyon_tessellation/0.13.0/lyon_tessellation/struct.VertexBuffers.html"&gt;&lt;code&gt;VertexBuffers&lt;/code&gt;&lt;/a&gt; output can be parametrized over the index type to provide the choice of &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt; or anything else that can be converted to a &lt;code&gt;VertexId&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In addition, the &lt;code&gt;GeometryBuilder&lt;/code&gt; trait and the tessellators are set up to properly handle running out of indices, interrupting the tessellation and returning an error instead of causing a panic as it previously did.&lt;/p&gt;
&lt;p&gt;This might sound like a detail but several people ran into it and the way the tessellator used to panic when running out of vertex ids was confusing so I am happy that this is now a thing of the past. My initial worry was that the added glue to forward and handle errors would regress performance (which it initially did by about 6%), but with a small amount profiling and tweaks I got the performance back within noise range of the original scores (on the benchmarks in the repository).&lt;/p&gt;
&lt;h2&gt;lyon_path&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_path"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_path"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_path"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_path/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This crate has received more attention than usual lately.&lt;/p&gt;
&lt;p&gt;The first thing people who update from earlier versions of lyon will notice is probably that &lt;code&gt;lyon::path::default::Path&lt;/code&gt; is now &lt;code&gt;lyon::path::Path&lt;/code&gt;. But there have been some more interesting developments than this namespace change.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/iterator/index.html"&gt;iterator APIs&lt;/a&gt; got a pretty major revamp. Previously the various flavors of path iterators would let you iterate over events such as &lt;code&gt;MoveTo(Point)&lt;/code&gt;, &lt;code&gt;Close&lt;/code&gt;, &lt;code&gt;LineTo(Point)&lt;/code&gt; and equivalent curve segments types, in a postscript fashion similar to how the paths are created, in which we don't repeat the start of the event since we already provided it as the end of the previous one.
This was simple to implement since it maps to how the path is stored, but pretty much every consumer of the API would have to keep track of both the previous end of segment and the starting position of the curve to do any meaningful work with the segments of the path.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;PathEvent&lt;/code&gt; enum looked like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;pub&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="nc"&gt;PathEvent&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;MoveTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;LineTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;QuadraticTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// control point, to&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// etc.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And now looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;pub&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="nc"&gt;PathEvent&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;MoveTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LineSegment&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LineSegment&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Quadratic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QuadraticBezierSegment&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// etc.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In other words, I shifted the burden of tracking this information from the user to &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/struct.Iter.html"&gt;the iterator&lt;/a&gt; implementation by making path events contain the actual segments and by providing the closing segment in &lt;code&gt;PathEvent::Close(LineSegment&amp;lt;f32&amp;gt;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I also removed &lt;code&gt;PathSegment::Arc&lt;/code&gt; (elliptic arcs automatically get approximated with a sequence of cubic bézier curves) and simplified the &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/iterator/trait.PathIterator.html"&gt;&lt;code&gt;PathIterator&lt;/code&gt; trait&lt;/a&gt; which is now a simple extension trait implemented for all &lt;code&gt;Iterator&amp;lt;Item = PathEvent&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There is also a new &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/struct.Cursor.html"&gt;&lt;code&gt;Cursor&lt;/code&gt; API&lt;/a&gt; which makes it possible to refer to specific positions within a path and work with portions of paths instead of always iterating over the entire path from the beginning.&lt;/p&gt;
&lt;p&gt;A &lt;a href="https://docs.rs/lyon_path/0.13.0/lyon_path/iterator/trait.FlattenedIterator.html#method.length"&gt;helper to approximate the length of a path&lt;/a&gt; using adaptive curve flattening was added, although Raph Levien wrote about &lt;a href="https://raphlinus.github.io/curves/2018/12/28/bezier-arclength.html"&gt;a faster way to evaluate the length of bézier curve segments&lt;/a&gt; which he implemented in in the &lt;a href="http://github.com/linebender/kurbo"&gt;kurbo&lt;/a&gt; crate. Perhaps some of this good stuff will make its way into lyon as well eventually.&lt;/p&gt;
&lt;p&gt;In the long term I want to experiment with more changes to the path data structure, for example making it generic over the vertex type to allow &lt;code&gt;f64&lt;/code&gt; coordinates and potentially arbitrary per-point attributes (for example one could want to store colors, line width, etc.).&lt;/p&gt;
&lt;h2&gt;lyon_algorithms&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_algorithms"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_algorithms"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_algorithms"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_algorithms/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A new crate was introduced this year! &lt;a href="https://docs.rs/lyon_algorithms/"&gt;lyon_algorithms&lt;/a&gt; contains a number of path related transformations and algorithms such as &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/hatching/index.html"&gt;generating hatching and dotting patterns&lt;/a&gt;, &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/splitter/struct.Splitter.html"&gt;splitting paths&lt;/a&gt;, &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/aabb/index.html"&gt;computing bounding boxes&lt;/a&gt;, &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/raycast/fn.raycast_path.html"&gt;ray casting&lt;/a&gt; and &lt;a href="https://docs.rs/lyon_algorithms/0.13.0/lyon_algorithms/walk/index.html"&gt;walking along a path at constant speed&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I wrote most of these algorithms for fun. I don't think I will pursue the same robustness goals as the fill tessellator there (path splitting has some very difficult edge cases when several segments overlap exactly for example), but I think that they are good enough to be useful to a lot of people.&lt;/p&gt;
&lt;p&gt;I'd love to add more algorithms there, like boolean operations, path simplification, path smoothing, path interpolation, and so on.&lt;/p&gt;
&lt;p&gt;I have used these algorithms to generate procedural shapes and print them with my &lt;a href="https://www.axidraw.com/"&gt;axidraw&lt;/a&gt; and it's a ton of fun. Hopefully, some people in the plotting community will find them useful.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Hatching example" src="https://nical.github.io/images/hatching-screenshot.png"&gt;&lt;/p&gt;
&lt;h2&gt;Work in progress&lt;/h2&gt;
&lt;p&gt;I mentioned at the beginning of the post that I have been making slow progress on two fronts:&lt;/p&gt;
&lt;h3&gt;A new fill tessellator&lt;/h3&gt;
&lt;p&gt;This work is happening in the &lt;a href="https://github.com/nical/lyon/pull/334"&gt;new-tess branch&lt;/a&gt;. The main motivations for this are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Better robustness against numerical precision issues. In broad strokes, the idea is to organize the algorithm so that it can detect and recover from precision bugs that break the invariants of the algorithm. It is a little hard to describe, but in a nutshell the approach is to accept that some arithmetic will produce results that break the invariant of the algorithm and split iterations of the main loop into an analysis phase where we get a chance to detect the error, backtrack one step and recover from it, and a mutation phase. In contrast the current tessellator interleaves mutations of its internal state with analysis of the geometry in a way that makes it hard to interrupt the iteration and recover if a bad state is detected.&lt;/li&gt;
&lt;li&gt;Support arbitrary vertex attributes. Today it is hard to associate external data such as colors or bone weights for animation to each vertex and use it in the output of the tessellator.&lt;/li&gt;
&lt;li&gt;Move away from fixed point numbers which the current tessellator uses internally. I originally thought that they would be the key to taming precision issues, but it didn't work out that well, and introduced new issues like a limited range of numbers that the tessellator can represent internally.&lt;/li&gt;
&lt;li&gt;Support for more fill rules (even-odd is the only currently supported fill rule in the current tessellator).&lt;/li&gt;
&lt;li&gt;Handling quadratic bézier curves directly in the tessellator. The tessellator would be able to either flatten curves on the fly during tessellation, or produce a mesh in which the curves could be evaluated in a fragment shader or tessellation shader. This goal longer term than the others, though.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So far the new tessellator is able to tessellate all of the non-self intersecting curves I have thrown at it (good thing lyon has a pretty large test suite), but doesn't detect intersections yet, and that's on purpose: ignoring intersections is a great way to mess the internal state of the algorithm up and see if it can recover and continue from there. I'll implement detecting and handling intersections eventually of course.
I have put no effort in performance yet (will get to that when the new tessellator is close to being usable), it doesn't handle curves and I haven't settled on a way to model the API to support arbitrary vertex attributes when vertices are added during tessellation (again because of self-intersections).&lt;/p&gt;
&lt;h3&gt;Higher quality monotone tessellation&lt;/h3&gt;
&lt;p&gt;By "higher quality", I mean reducing the amount of thin triangles that are generated by the algorithm. Long thin triangles have undesirable properties. For example they tend to produce precision issues when used in certain algorithms like physics simulation, and be &lt;a href="https://www.g-truc.net/post-0662.html"&gt;slower to render on the GPU&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The monotone polygon decomposition approach used in lyon has a tendency to produce long horizontal triangles in some cases. I have a prototype that improves upon this but fails in some cases. To be continued.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Thin triangles illustration" src="https://nical.github.io/images/rustfest/adv-monotone.svg"&gt;&lt;/p&gt;
&lt;h2&gt;Wrapping up&lt;/h2&gt;
&lt;p&gt;2018 Was a good year for lyon. In this post I put forth Tom Klein's contribution, but other people also helped get the project where it is today. If your name is on &lt;a href="https://github.com/nical/lyon/wiki/Contributors"&gt;the contributor list&lt;/a&gt;, then you are awesome and I thank you.&lt;/p&gt;
&lt;p&gt;Hopefully 2019 will be the year where the new tessellator matures and replaces the current one and maybe the start of a small vector graphics rendering crate built on top of gfx-hal.&lt;/p&gt;</content><category term="lyon, rust"></category></entry><entry><title>2d graphics in Rust discussion - A look at GPU memory management</title><link href="https://nical.github.io/posts/rust-2d-graphics-02.html" rel="alternate"></link><published>2018-10-28T00:00:00+02:00</published><updated>2018-10-28T00:00:00+02:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2018-10-28:/posts/rust-2d-graphics-02.html</id><summary type="html">&lt;p&gt;In this post I'll write about an piece of the low level details of an hypothetical rust 2d graphics crate built on top of &lt;a href="https://github.com/gfx-rs/gfx"&gt;gfx-hal&lt;/a&gt;. Gfx provides a vulkan-like interface implemented on top of vulkan, d3d12, metal or flavors of OpenGL. just like the &lt;a href="https://nical.github.io/posts/rust-2d-graphics-01.html"&gt;previous post&lt;/a&gt; this is in the …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post I'll write about an piece of the low level details of an hypothetical rust 2d graphics crate built on top of &lt;a href="https://github.com/gfx-rs/gfx"&gt;gfx-hal&lt;/a&gt;. Gfx provides a vulkan-like interface implemented on top of vulkan, d3d12, metal or flavors of OpenGL. just like the &lt;a href="https://nical.github.io/posts/rust-2d-graphics-01.html"&gt;previous post&lt;/a&gt; this is in the context of recent discussions about a 2d graphics crate in rust.&lt;/p&gt;
&lt;p&gt;I won't actually write much about 2d graphics specific things this time, because a lot of these low level concerns are agnostic to whether the rendered content is in two or three dimensions. I'll mostly focus on memory management and command submission.&lt;/p&gt;
&lt;p&gt;This low level thing I am going to talk about isn't a 2d graphics API that most users would play with but rather a base component on top of which various rendering techniques could be implemented (for example using &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt;, &lt;a href="https://github.com/pcwalton/pathfinder"&gt;pathfinder&lt;/a&gt; or some other approach), and this base component would be independent of these rendering techniques.&lt;/p&gt;
&lt;h2&gt;Organizing the input of drawing commands on the GPU&lt;/h2&gt;
&lt;p&gt;Let's have a look at &lt;a href="https://github.com/servo/webrender"&gt;WebRender&lt;/a&gt;. Most drawing primitives in WebRender use very simple geometry (axis-aligned rectangles) with shaders of varying complexity that compute directly on the GPU what happens to the pixels covered by the geometry. If you've ever done serious work with GPU, one of your primary concerns most likely was to batch rendering commands and avoid state changes. To render a few thousand rectangles, it would be terribly inefficient to have a loop on the CPU that sets some parameters and kicks a drawing command for each rectangle. So what we do is write a lot of parameters into buffers which are sent to the GPU, and kick a few drawing commands, that will each render maybe thousands of rectangles in one go using instancing.
The drawing parameters we write into the buffer contain information such as the position and size of the rectangle in layout space, a transformation to go from layout space to screen space, some flags about whether some anti-aliasing must be done, the positions and sizes of some source images in a texture atlas if need be (for example to apply a texture or a mask), the z-index of the primitive to write into the depth buffer, etc.
The vertex shader uses an instance id to find the right information in a per-instance parameter buffer, transforms the geometry (a unit quad) into the right rectangle on screen, forwards some data to the fragment shader and the latter executes the per pixel logic (read from the source textures, apply some effect, write output color, etc.).&lt;/p&gt;
&lt;p&gt;&lt;img alt="gpu memory organization example" src="https://nical.github.io/images/gpu-mem-01.svg"&gt;&lt;/p&gt;
&lt;p&gt;This approach is fairly generic, not particular to WebRender (a lot of games do this sort of thing) and works quite well.
What's interesting here is that if you get to write the shaders yourself you have a lot of flexibility in how the input data is organized in GPU memory. You can put all of the parameters for a given instance contiguous together or add levels of indirection, share some common parameters among many instances or even devise your own compression scheme for your data. All that matters is for the CPU code to know how to writes bytes and the shader to know how to find the data in GPU memory and interpret it the right way, and then it is up to you to decide what trade-off to make about simplicity, memory usage and data locality.&lt;/p&gt;
&lt;p&gt;I like to think of the problem of submitting commands to the GPU as some sort of encoding/decoding problem. Got data on one side, some binary representation in GPU buffers and need to read that correctly in the shader. As such, submitting commands is very tied to GPU memory management since it amounts to writing the correct information in the right place.
In the purpose of a 2d graphics library, what kind of representation would we want? Well we don't know because the shape the data you write into GPU memory may depend on the details of the rendering technique itself and I mentioned earlier that I want this low level component to be agnostic to that. Some other layer above will deal with it and for now we can focus providing a way to write data into these GPU buffers.&lt;/p&gt;
&lt;h2&gt;Dealing with GPU memory allocation&lt;/h2&gt;
&lt;p&gt;Let's first have a look at some properties I want from a low level GPU memory management system:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Be able to write commands from several threads in parallel.&lt;/li&gt;
&lt;li&gt;Be able to separate memory that is rarely updated from memory that we update often in order to minimize transfer and choose the right kind of memory heap.&lt;/li&gt;
&lt;li&gt;The system should be embeddable in another application that uses gfx.&lt;/li&gt;
&lt;li&gt;Ideally the shader should not have to care about whether a particular property is static or dynamic.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Legacy graphics APIs had a lot of memory management magic done in the driver. Modern APIs such as vulkan move this responsibility to the user of the API (us). Simply allocating a lot of small memory segments has a lot overhead. &lt;a href="https://youtu.be/zSG6dPq57P8?t=1163"&gt;AMD's recommendation&lt;/a&gt; is to allocate large chunks of memory segments of 256 MiB and manage sub-allocations within these coarse chunks, others talk about 128 MiB blocks, &lt;a href="https://developer.nvidia.com/vulkan-memory-management"&gt;nVidia's recommendation&lt;/a&gt; is to manage all allocations out of as few as possible large contiguous memory chunks.&lt;/p&gt;
&lt;p&gt;So we can decide to have these large memory blocks with various allocation schemes within them, from a simple bump allocator to a general purpose fully-featured allocator.&lt;/p&gt;
&lt;p&gt;For per-frame data which is overwritten each time, a bump allocator looks like a good fit: It is simple, fast and we can easily write a lock-free one that is usable in parallel. For completely static (as in very long-lived) allocations, bump allocators can also work well since we don't need to worry about fragmentation. The area in the middle is a bit tricker. I don't have a precise definitive allocation strategy to provide here, other than that in my opinion, nesting simple and efficient allocators is the way to go. Group memory allocations into blocks of the same lifetime that get deallocated in one go, and try to keep the complicated parts of memory managements for fewer coarser chunks, also try to group allocations by update frequency. In other words, use specific, simple and deterministic allocation strategies rather than relying on a single complicated one-size-fits-all allocation interface like if you had jemalloc for your GPU. Making such a general purpose allocator is for one very hard, and ensuring good and deterministic performance characteristics is even harder.&lt;/p&gt;
&lt;p&gt;This idea of nested allocators is a good fit for something that can be embedded into another graphics engine. For example the coarse allocations could be requested to the embedder and the 2d renderer would manage its own allocations inside of them.
For multi-threading this is also good: Some thread-safe allocator can allocate chunks in parallel, and these chunks could be managed independently in single-thread fashion but each on their single thread by a nested allocator that is hard to make thread-safe.&lt;/p&gt;
&lt;p&gt;Some allocations are best managed manually (explicit allocation and deallocation), while for some other things, using a cache can be more interesting: Each frame, the CPU side requests that the allocations that are used within the cache stay alive, and if an allocation isn't used for a long time, the cache implicitly deallocates it. The next time the allocation is requested, the cache will politely tell the source of the request that the allocation doesn't exist anymore, a new allocation is made and the data is transfered again. A lot the GPU memory management in WebRender is done that way. Having the right heuristics about when to expire cache entries is not always simple.&lt;/p&gt;
&lt;p&gt;So far I talked about allocations in the sense of figuring out how many bytes at which offset to reserve in GPU memory for this and that, but we also want to write into these allocations. Often times people think of allocating and writing into memory as single thing. When writing &lt;code&gt;let five = Box::new(5)&lt;/code&gt; you both ask the allocator to figure out where the value will be and write the value in memory. But sending data to the GPU isn't that simple. In general you can't assume that the memory you are writing to on the CPU is the one that gets read in the shaders. There are several memory heaps with different characteristics (CPU-visible, GPU-visible, fast/slow to read/write on the CPU/GPU, etc.). In practice this means that for a lot things the data is first written into a staging buffer that is CPU-visible, then copied from there into memory that is fast to read from the shaders.&lt;/p&gt;
&lt;p&gt;&lt;img alt="staging buffer" src="https://nical.github.io/images/gpu-mem-02.svg"&gt;&lt;/p&gt;
&lt;p&gt;One strategy could be to work with a large GPU buffer for the shader to read and generally smaller staging buffers into which we write only the parts that have changed. In this scheme the shader gets to read from a single contiguous buffer containing static and dynamic data alike and doesn't have to be aware of that. This is at the cost of copying from the staging buffer for data that we now will only read for a single frame. If a lot of data needs to be updated and read only once each frame, using another type of GPU memory heap that is both accessible to the CPU and the GPU, is slower to read in the shader but depending on how the data is read it might still be faster than the copy of the staging buffer. &lt;a href="https://youtu.be/zSG6dPq57P8?t=991"&gt;An example&lt;/a&gt; given for this type of memory heap is particle positions in a game, where by definition we know all of it will change each frame. The downside is that the shader can't pretend it is in a unified address space with the rest, so it isn't agnostic to what is animated and what is not. This might not be a good fit for cases where, say, some of the positions are animated while others are not and it all goes through the same code path in the shader.
Another thing to be careful about is that some types of memory heaps use write-combined memory which is ideal to fill the staging buffer but can perform poorly if we don't pay attention to how we write into it. So we have to allocate full aligned multiple-of-cacheline sized chunks and avoid random access.&lt;/p&gt;
&lt;h2&gt;What's next?&lt;/h2&gt;
&lt;p&gt;Phew. That was a lot of words just for pushing some bytes to the GPU! I merely presented some challenges, proposed certain directions from very far away and haven't even really talked about rendering (the fancy tricks that goes into those shaders, generating the geometry and all).&lt;/p&gt;
&lt;p&gt;But I believe this is an important part of the foundation. It is built upon mostly independent pieces and that's already some code that needs writing. Fortunately, this weekend was the first in a while that I had time to sit down and do that so I took one of gfx-hal examples and started writing a few things around it. So far I only have a simple &lt;a href="https://github.com/nical/lyon/blob/371af479cd743c102487835a74299ac50967cadd/renderer/src/allocator.rs#L4"&gt;bump allocator&lt;/a&gt;, some &lt;a href="https://github.com/nical/lyon/blob/371af479cd743c102487835a74299ac50967cadd/renderer/src/writer.rs#L93"&gt;glue to use it and write into memory&lt;/a&gt; from multiple threads, a simple and dumb &lt;a href="https://github.com/nical/lyon/blob/371af479cd743c102487835a74299ac50967cadd/renderer/src/allocator.rs#L54"&gt;retained allocator&lt;/a&gt; for coarse allocations, some &lt;a href="https://github.com/nical/lyon/blob/371af479cd743c102487835a74299ac50967cadd/renderer/src/gfx.rs"&gt;reexports of the gfx types&lt;/a&gt; without generics all over the place (since the backend is selected with feature flag), and various &lt;a href="https://github.com/nical/lyon/blob/371af479cd743c102487835a74299ac50967cadd/renderer/src/lib.rs#L99"&gt;small utilities&lt;/a&gt;. That's not much, I'm still spending time getting familiar with gfx, but that's a humble start.&lt;/p&gt;
&lt;p&gt;I'll end this post with hand-wavey overview of how I see this stuff fitting into the bigger picture:&lt;/p&gt;
&lt;p&gt;&lt;img alt="boring architecture diagram" src="https://nical.github.io/images/gpu-mem-03.svg"&gt;&lt;/p&gt;
&lt;p&gt;From bottom to top there is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A gfx-device that is owned by an embedder.&lt;/li&gt;
&lt;li&gt;The embedder can be the default one or some glue to integrate with a specific engine or app).&lt;/li&gt;
&lt;li&gt;The low level components contain anything that is mostly independent of the rendering technique, for example a lot of the memory management code that I wrote about in this post. The goal of the low level components is to make it easy to write efficient rendering components without having each of them reinvent the common pieces. Rendering components do the more interesting stuff: They register passes, shaders, and implement fun rendering techniques. An example of rendering component could be a glyph renderer using pathfinder. Another one could be a tessellated polygon renderer that uses lyon, another one could be something that is optimized for rendering many axis-aligned rectangles as is common for UIs. Rendering components inform the command submission system which draw calls are order-independent as well as some global requirements such as depth/stencil behavior, etc. This lets the low level pieces figure out an efficient batching strategy.&lt;/li&gt;
&lt;li&gt;You see on top of that several "API" boxes. These take care of high level logic and providing user facing APIs. Each API would have to make different tradeoffs and focus on different use cases, picking whatever rendering components they want to use.
As much as possible I would like to avoid compromises outside of the "API" boxes which will be potentially high level abstractions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'm intentionally describing this in very broad terms. The idea behind separating things this way is to be able to experiment with various rendering techniques without starting from scratch each time, and also aim for an extendable architecture if things work out. There is a lot of pieces missing and the boundaries will move as real code gets written but this sets a general direction I am happy with for a low level GPU based 2d graphics library.&lt;/p&gt;</content><category term="graphics"></category></entry><entry><title>Following up on the 2d graphics in Rust discussion</title><link href="https://nical.github.io/posts/rust-2d-graphics-01.html" rel="alternate"></link><published>2018-10-14T00:00:00+02:00</published><updated>2018-10-14T00:00:00+02:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2018-10-14:/posts/rust-2d-graphics-01.html</id><summary type="html">&lt;p&gt;Raph Levien recently published &lt;a href="https://raphlinus.github.io/rust/graphics/2018/10/11/2d-graphics.html"&gt;A crate I want: 2d graphics&lt;/a&gt; on his blog, which started some interesting discussions &lt;a href="https://www.reddit.com/r/rust/comments/9nhhh8/a_crate_i_want_2d_graphics/"&gt;on reddit&lt;/a&gt;. At the same time there is a nascent discussion on the &lt;a href="https://github.com/draw2d/rfcs/issues/1"&gt;draw2d&lt;/a&gt; repository (which doesn't have any code at this point) about a potential 2d graphics crate.&lt;/p&gt;
&lt;p&gt;These discussions contain …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Raph Levien recently published &lt;a href="https://raphlinus.github.io/rust/graphics/2018/10/11/2d-graphics.html"&gt;A crate I want: 2d graphics&lt;/a&gt; on his blog, which started some interesting discussions &lt;a href="https://www.reddit.com/r/rust/comments/9nhhh8/a_crate_i_want_2d_graphics/"&gt;on reddit&lt;/a&gt;. At the same time there is a nascent discussion on the &lt;a href="https://github.com/draw2d/rfcs/issues/1"&gt;draw2d&lt;/a&gt; repository (which doesn't have any code at this point) about a potential 2d graphics crate.&lt;/p&gt;
&lt;p&gt;These discussions contain a lot of interesting comments. One notable thing is that "2d graphics" means different things to different people. Some people want to render UIs, some people want to make games with rich vector graphics, some people want to be able to render complex but static SVG documents, some people want something designed for modern GPUs, some people want a library that can be used without a GPU, some want it low level, other want it high level, &lt;em&gt;et caetera&lt;/em&gt;.
Having worked with and on different approaches to 2d graphics rendering, I am convinced that 2d graphics isn't a single problem with an established solution, but rather collection of different problems which are best solved with very different solutions.&lt;/p&gt;
&lt;p&gt;Because of that I would like this discussion to branch into several specific topics. In this post I'll talk about 2d graphics for the web and for user interfaces (a case could be made about separating the two of course), to a large extent with the intent to underline how specific the needs of these use cases are. Before I do that I'll write a few words about "canvas-like" graphics APIs.&lt;/p&gt;
&lt;h2&gt;Canvas, Cairo, Skia, QPainter - The immediate mode painting model&lt;/h2&gt;
&lt;p&gt;&lt;img alt="canvas-like APIs" src="https://nical.github.io/images/canvas-api.svg"&gt;&lt;/p&gt;
&lt;p&gt;A lot of the most common 2d graphics APIs look somewhat similar: We have a context object which holds various drawing states like the current transform, pattern, or clip, we have a way to describe paths in post-script fashion (for example &lt;code&gt;context.move_to&lt;/code&gt;, &lt;code&gt;context.line_to&lt;/code&gt;, or if we are lucky, actual path objects that can be retained and reused). The general mental model is that you specify each drawing operation in back to front order and pixels are being painted immediately at each operation (or this is what the API pretends) but in practice drawing might be deferred so that the underlying implementation can take advantage of knowing about all of the elements and perform some global optimizations. For example CPU backends tend paint each drawing command individually, but GPU implementations pretty much need to be able to perform global optimizations in order to get acceptable performance. Another important aspect of these APIs is that they don't retain a description of the scene, which means that in order to render interactive content, you will submit the commands again each frame with some modifications for the parts that are changing. A common optimization when using this drawing model is for the user to track which region of the final image has changed and only redraw that part (in Firefox we call it invalidation).&lt;/p&gt;
&lt;p&gt;Generally, implementing an efficient GPU backend for a pre-existing canvas-like API has proven to be difficult (doable but difficult). A lot of these APIs were designed before GPUs existed or became what they are now, and often a lot of expensive transformations need to happen between the API and the underlying GPU command submissions.&lt;/p&gt;
&lt;h2&gt;Compositors&lt;/h2&gt;
&lt;p&gt;When motion comes into play (through animations or scrolling), re-rendering rectangles, paths, text and whatever else is moving at a high frame rate can become expensive with these drawing models. A very common solution to this problem is to group elements that tend to move together and paint them into retained surfaces that are often called layers (at least in the world of web browsers). Scrolling then becomes a matter of moving one or several layers and compositing them together to form the resulting image. This compositing operation is the job of... the compositor. Compositing within an application is very similar to compositing for a window manager, to the point where all modern window managers now provide APIs to let applications delegate the work of compositing their layers to the window manager, which avoids one compositing step, saves cycles, memory bandwidth and power. It is somewhat painful that all platforms expose this functionality in subtly different ways, but I think that it would be a mistake for any new UI toolkit to ignore it if they have a concept of retained surfaces.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Gecko compositor" src="https://nical.github.io/images/gecko-compositor.png"&gt;&lt;/p&gt;
&lt;h2&gt;Rendering web pages and UIs&lt;/h2&gt;
&lt;p&gt;By now I already gave away some of the details about how a lot of web browsers and UI toolkits work: an immediate mode painting abstraction, on top of which an invalidation system and a compositor were implemented to paper over the difficulty of rendering at 60 frames per second (without draining too much power). This is pretty much how Firefox (and most other browsers), Gtk and Qt have been historically approaching 2d graphics. This model is also to some extent something that Firefox, Gtk and Qt have or are in the process of going away from. I'll get to that in a moment, but before that I want to look at what drawing primitives are important for a web browser and a UI toolkit:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Text. Oh text. Text is of course very important in this context and &lt;em&gt;must&lt;/em&gt; have a particular look in each platform because a lot of users are bothered when hinting or anti-aliasing in an app doesn't match the look of the rest of the platform. In practice this means a lot of graphics libraries go through great lengths and pain to use the font rendering system of each platform they support. Text is hard. I wont get into these details but the people who implement the myriad of things that happen between loading a font file and the letters of this blog post showing up on your screen are heroes (no self-congratulations, I only touched very small portions of that). Patrick Walton is working on the &lt;a href="https://github.com/pcwalton/font-kit"&gt;font-kit crate&lt;/a&gt; which will hopefully erase some of the pain of dealing with font on each platform. I haven't used it yet but it's something to keep an eye on. Unless you are on a very high dpi screen, sub-pixel positioning and anti-aliasing make text a lot easier and nicer to read. One might decide to only target high dpi displays and punt on these features, but I wouldn't call that an easy decision and it will rule out some use case for sure.&lt;/li&gt;
&lt;li&gt;Simple shapes: mostly axis aligned rectangles and rounded rectangles, filled and their outlines.&lt;/li&gt;
&lt;li&gt;Very complex clipping scenarios: That one might not be necessary for some UI toolkits, but I'll mention it because clipping is a hard problem when your job is to render web pages. In any case it took quite a bit of trial and error to get that work with all use cases in WebRender.&lt;/li&gt;
&lt;li&gt;A few effects like drop shadows and blurs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Notice how I didn't mention arbitrary paths? Of course these need to be implemented in a web browser but without them you can already render a large portion of the web. Any modern UI toolkit also needs to render arbitrary vector graphics to provide resolution independent icons and some types of UI widgets, but the need doesn't compare to the heaps of rectangles and text that compose UIs and web pages.
Since you still need to support both arbitrary vector graphics and these specific simple shapes, you can simply focus on rendering the complex cases and you'll get the simple case for free, right? Except that in doing so, by not making the overwhelmingly most common case a first class citizen of the system a lot of potential for performance optimization would be lost.
Today, WebRender doesn't know how to render arbitrary shapes. It's main primitives are (rounded) rectangles and more complex shapes just go through a fall-back mechanism that is part of Gecko and provides WebRender with the resulting content already rasterized. We'll eventually implement path rendering on the GPU but the current situation is good enough for us to ship WebRender first with the fall-back.
My understanding is that the situation is similar with Gsk (Gtk's next generation rendering infrastructure): arbitrary vector graphics are rasterized using Cairo on the CPU while great care goes into rasterizing rectangles on the GPU.&lt;/p&gt;
&lt;p&gt;Interestingly, for a lot of people path rendering is the central theme when thinking about 2d graphics. My point isn't to state what features are more important than others for a 2d graphics library, but really to stress how different the use cases are and that Rust does not need a single 2d graphics crate, but several, each with different goals and trade-offs.&lt;/p&gt;
&lt;p&gt;Speaking of focus, I will now attempt to get my chaotic train of thought together and come back to the topic of web pages and UI toolkit I was writing about a few lines earlier.&lt;/p&gt;
&lt;h2&gt;Animation&lt;/h2&gt;
&lt;p&gt;I already mentioned motion. It is important enough that browsers and UI toolkits went from a simple "draw each element directly into the pixels of the window" model to embedding a compositor and/or relying on the window manager's compositor to accelerate moving things around. In my opinion, not taking motion/animation into account is one of the biggest mistakes a new graphics API design can make in he context of UIs (and in many other use cases). Frame N+1 is usually very similar to frame N, and taking advantage of this is key to get good performance and battery usage in rich and interactive experiences. There are different ways in which two frames can be similar. For example a few elements could be added, or all elements could exist in the two frames with different positions. For some APIs the latter might be considered as being two totally different scenes because all elements have changed, for other APIs that retain the structure of the scene it could just be thought of as the same frame with a different array of animation parameters. Whether the latter is superior to the former really depends on what you think the common use cases will be what is worth optimizing for.
WebRender treats updates with several levels of priority. Scrolling for example &lt;em&gt;must&lt;/em&gt; be able to operate at 60 frames per second, some larger changes to the structure of the scene can be more expensive to operate and are being carried asynchronously to ensure scrolling remains smooth. This is one of the many solutions to the common problem of having to deal with operations that could blow the frame budget. Another way could be to allow expensive work to be done asynchronously by users of the API prior to submitting rendering instructions. In any case I think that it is important to identify these bottlenecks and design the system in a way that prevents them from hurting frame rate.&lt;/p&gt;
&lt;p&gt;In term of API, WebRender is much higher level than a traditional canvas-like API. Instead of building a single frame by submitting drawing commands, consumers of the API build a retained representation made of nested "display lists", and several frames will be rendered from this representation when animated properties of these display lists change (for example scrolling, or other types of animations). By squinting really hard one might see the display list building API as a sort of canvas-like API that builds a scene instead of an image, with an added notion of animated properties. But the display list building API itself doesn't have the generalist and flexible graphics API look of a Cairo or a Skia, instead focusing on describing positioned CSS primitives.&lt;/p&gt;
&lt;h2&gt;Wrapping up&lt;/h2&gt;
&lt;p&gt;At this point my plan was to delve into how WebRender approaches rendering on the GPU in more details and explain in what ways it fundamentally differs from Firefox's previous approach, but I already wrote too many words for a single post. To be honest, I think that WebRender already has the potential to fill the UI rendering niche. Some useful features are missing (for example a full software fallback), but these features are wanted in the long term anyway, so better add them (pull requests are welcome!) than try to replicate the colossal amount of effort that already went into the project.&lt;/p&gt;
&lt;p&gt;Let this post be about me trying to convince you that rendering UIs comes with very specific design constraints and requirements, and that other niches which I failed to talk about would benefit from very different solutions. Whenever I have time to sit down and write another post I'll try to explain what I think would be a good direction for an hypothetical low-level crate focused on path rendering on the GPU with an eye for complex and dynamic scenes. Something very different in goal and scope from WebRender (and in some ways complementary). My hope is that I can stir some of the potential "Let's get together and make a 2d graphics crate" vibe towards that vision.&lt;/p&gt;</content><category term="graphics"></category></entry><entry><title>RustFest Paris - Part 2 - Path rendering challenges</title><link href="https://nical.github.io/posts/rustfest-paris-02.html" rel="alternate"></link><published>2018-06-19T00:00:00+02:00</published><updated>2018-06-19T00:00:00+02:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2018-06-19:/posts/rustfest-paris-02.html</id><summary type="html">&lt;p&gt;This is the second part of a series about the talk I gave at &lt;a href="https://paris.rustfest.eu/"&gt;RustFest Paris&lt;/a&gt; about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt;, a crate that helps you render vector graphics on the GPU in Rust.&lt;/p&gt;
&lt;p&gt;The recordings can be found &lt;a href="https://app.media.ccc.de/v/rustfest18-7-vector_graphics_rendering_on_the_gpu_in_rust_with_lyon"&gt;here&lt;/a&gt; or on &lt;a href="https://www.youtube.com/watch?v=2Ng5kpDirDI&amp;amp;list=PL85XCvVPmGQgdqz9kz6qH3SI_hp7Zb4s1&amp;amp;index=7"&gt;YouTube&lt;/a&gt; if you prefer.&lt;/p&gt;
&lt;p&gt;Previous episode:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="rustfest-paris-01.html"&gt;Part 1 - Intro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;The problem …&lt;/h1&gt;</summary><content type="html">&lt;p&gt;This is the second part of a series about the talk I gave at &lt;a href="https://paris.rustfest.eu/"&gt;RustFest Paris&lt;/a&gt; about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt;, a crate that helps you render vector graphics on the GPU in Rust.&lt;/p&gt;
&lt;p&gt;The recordings can be found &lt;a href="https://app.media.ccc.de/v/rustfest18-7-vector_graphics_rendering_on_the_gpu_in_rust_with_lyon"&gt;here&lt;/a&gt; or on &lt;a href="https://www.youtube.com/watch?v=2Ng5kpDirDI&amp;amp;list=PL85XCvVPmGQgdqz9kz6qH3SI_hp7Zb4s1&amp;amp;index=7"&gt;YouTube&lt;/a&gt; if you prefer.&lt;/p&gt;
&lt;p&gt;Previous episode:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="rustfest-paris-01.html"&gt;Part 1 - Intro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;The problem&lt;/h1&gt;
&lt;p&gt;Screens tend to have a lot of pixels these days.&lt;/p&gt;
&lt;p&gt;&lt;img alt="screens" src="https://nical.github.io/images/rustfest/screen.svg"&gt;&lt;/p&gt;
&lt;p&gt;To the point that when rendering interesting vector graphics (or rendering anything, really) at a high resolution, the per-pixel work adds up and becomes a real challenge for the CPU to process sequentially. Our goal here is to render complex vector graphics at interactive frame rates (This typically means a 16ms budget per frame) and we'd obviously like to have some processing power left to do other things.&lt;/p&gt;
&lt;h1&gt;Filling paths on the CPU&lt;/h1&gt;
&lt;p&gt;I am going to use the term "rasterization" and "rasterizer" quite a bit in this post. &lt;a href="https://en.wikipedia.org/wiki/Rasterisation"&gt;Rasterization&lt;/a&gt;, in a nutshell, is the action of turning vector graphics into raster graphics. In other words it's taking vector graphics and rendering them into pixels. I'll focus on filling paths which is probably the most common primitive, but it's not the only thing vector graphics are made of.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What's the deal with GPUs, anyway? I have a beefy CPU, isn't that enough?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Because images are usually laid out in memory row by row in a contiguous buffer, it's ideal to fill shapes from top to bottom, row after row to maximize cache locality of memory accesses and help the CPU's prefetcher.
So it comes without surprise that most path filling implementations use &lt;a href="https://en.wikipedia.org/wiki/Sweep_line_algorithm"&gt;sweep-line algorithms&lt;/a&gt;. The general idea is to start with a list of the path's edges sorted from top to bottom. Imagine an imaginary line (the sweep-line) that traverses the output image a row of pixels at a time. We maintain another list, this one containing the edges that intersect the current row, sorted from left to right (let's call them active edges). During the traversal we use the first sorted list to know which edges to add to the active edge list and when. For each row we go through the active edge list to figure out where to start and stop filling pixels, as well as what to do with pixels that are partially covered.&lt;/p&gt;
&lt;p&gt;&lt;img alt="sweep line" src="https://nical.github.io/images/rustfest/sweepline.gif"&gt;&lt;/p&gt;
&lt;p&gt;There are variations around this algorithm. For example some implementations run the algorithm in a single pass while others will first generate a data structure that represents the spans of pixels to fill and then fill the pixels in a second pass.&lt;/p&gt;
&lt;p&gt;Sweep-lines are very useful when dealing with a lot of different geometry problems (2D and 3D alike) I think that I'll come back to what I like so much about them in another post (maybe in part 3).&lt;/p&gt;
&lt;p&gt;For now if you are interested in knowing more about this stuff I recommend having a look at &lt;a href="https://searchfox.org/mozilla-central/rev/3737701cfab93ccea04c0e9cab211ad10f931d87/gfx/skia/skia/src/core/SkScan_Path.cpp#106"&gt;Skia's scanline rasterization code&lt;/a&gt;, or &lt;a href="http://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/raster/ftraster.c?id=af585ad4fec965fa85f5d61c759f3bc940936de4#n2652"&gt;Freetype's&lt;/a&gt;. The coding style is different but the overall principle is the same. Oh and since this blog post is written in the context of rustfest, you can check &lt;a href="https://github.com/redox-os/rusttype/blob/master/src/rasterizer.rs"&gt;rusttype's rasterizer&lt;/a&gt; out too, it's implemented in rust.&lt;/p&gt;
&lt;p&gt;&lt;img alt="scanline fill" src="https://nical.github.io/images/rustfest/raster.svg"&gt;&lt;/p&gt;
&lt;p&gt;There is another approach worth mentioning implemented in &lt;a href="https://medium.com/@raphlinus/inside-the-fastest-font-renderer-in-the-world-75ae5270c445"&gt;font.rs&lt;/a&gt;, which involves rendering information about the outline of the shape in an accumulation buffer and using that as input to fill the shape in a single tightly optimized loop over the destination image. Notable about this approach is the simplicity of the main filling loop. It runs the same logic on all pixels inside and outside of the shape with very few branches which is very efficient on modern CPUs, at the expense of going over pixels that are outside the shape. When rendering very small images this trade-off works wonderfully. When rendering at very large resolutions, having a sparse representation to avoid touching pixels outside of the shape begins paying off.&lt;/p&gt;
&lt;p&gt;This is a good segue into an important point: There is no optimal one-size-fits-all (or should I say, one-fits-all-sizes!) solution.
When filling a small amount of pixels, a lot of time is typically spent computing the anti-aliasing along the edges, while paths that cover lots of pixel tend to put more pressure on memory bandwidth filling the interior.&lt;/p&gt;
&lt;p&gt;With lyon I focused on large paths covering many pixels, and I wouldn't advise using lyon to render very small text. In another post in this series I will talk a bit about &lt;a href="https://github.com/pcwalton/pathfinder"&gt;pathfinder&lt;/a&gt; which implements two algorithms: one for small resolutions (typically text), and one for larger paths.
I think that there is no way around having dedicated implementations if you want to cover both use cases optimally.&lt;/p&gt;
&lt;h1&gt;Overdraw&lt;/h1&gt;
&lt;p&gt;We saw how to figure out which pixels are inside a shape and fill them. From there to a drawing containing hundreds of paths the process is usually to render these paths individually from back to front, so that front-most elements don't get overwritten by the ones behind them.
Simple enough, however this means that for drawings that are built upon many shapes stacked on top of one another like the famous GhostScript tiger, pixels will typically get written to many times. It's quite a shame, because it means that hidden parts add to the rendering cost just as much as the rest even though they do not contribute to the final image.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ghostscript tiger overdraw" src="https://nical.github.io/images/rustfest/tiger-overdraw.svg"&gt;&lt;/p&gt;
&lt;p&gt;The image above gives an idea of the overdraw for the GhostScript tiger. The lighter a pixel is, the more times it is written to with a traditional back to front rendering algorithm.&lt;/p&gt;
&lt;p&gt;Where overdraw really hurts is usually memory bandwidth. Unfortunately hammering memory tends to make every thing else slower as well. The other threads end up sitting around waiting for memory which limits parallelism, and after the algorithm is done running, other code will typically run into cold caches. It is very hard to avoid this cost in the context of rasterizing 2D graphics on the CPU (in the best case scenario we have to touch every pixel at least once which is already quite a lot).
I have to mention a very cool technique that helps a lot here: the "full-scene rasterizer" approach which consists in having a single sweep-line that renders all paths at once and therefore can touch pixels only once. The rumor has it that the Flash runtime has such an implementation. See also &lt;a href="https://github.com/jrmuizel/full-scene-rasterizer/"&gt;Jeff Muizelaar's full-scene rasterizer&lt;/a&gt; which is open-source. This is however quite hard to implement.&lt;/p&gt;
&lt;h1&gt;What about games?&lt;/h1&gt;
&lt;p&gt;So how do games manage to render so much complex content at interactive frame rates?
For a large part the answer is that games almost always use the GPU for graphics tasks. GPU's have been historically designed and optimized specifically for the needs of the games industry. It would be great if we could leverage these hardware level optimizations when working with 2D content.&lt;/p&gt;
&lt;p&gt;Now saying that something's going to be fast because it uses the GPU is certainly not enough. It is very easy to do slow things with a GPU, especially when trying to port CPU code over. Rather than try to adapt a CPU algorithm to the GPU let's try to reformulate our 2D rendering problem in a way that corresponds to the type of inputs GPUs typically get.&lt;/p&gt;
&lt;p&gt;&lt;img alt="3D rendering" src="https://nical.github.io/images/rustfest/3d.svg"&gt;&lt;/p&gt;
&lt;p&gt;The vast majority of 3D content in interactive applications is made of triangle meshes. The GPU has dedicated hardware for dealing with triangles which makes this primitive very appealing for us. Perhaps if we turn vector shapes into flat triangle meshes (conceptually like a 3D mesh with z = 0) we can get somewhere, and that's the direction I took with lyon.
There are other approaches to rendering vector graphics on the GPU. As I mentioned earlier I don't believe in a one-size-fits-all solution, however I am pretty confident about geometry-based approaches (leveraging the triangle rasterizer) for the use cases I care most about.&lt;/p&gt;
&lt;p&gt;Another interesting feature of the GPU's rasterization pipeline is the depth buffer which contains the depth of each pixel in screen-space. This allows games to render opaque objects in any order and reject pixels that are further behind if something closer to the viewer has already been rendered at that location.
This is a convenient trick for correctness but it is also a great tool to reduce memory bandwidth, since by rendering opaque objects front to back, one can minimize the amount of time pixels are written to and greatly reduce memory bandwidth (remember that memory bandwidth was a big issue for CPU rasterization). Transparent objects are then rendered back to front since painting order actually matters for them.&lt;/p&gt;
&lt;p&gt;&lt;img alt="z-buffer" src="https://nical.github.io/images/rustfest/zbuffer.png"&gt;&lt;/p&gt;
&lt;p&gt;The illustration above was not in the rustfest presentation but perhaps it will help understanding what I am getting at with the depth buffer savings. This is a trick we use in WebRender that consists in rendering opaque shapes in front to back order with the depth buffer enabled to avoid touching pixels many times.
The memory bandwidth savings are actually greater than they seem thanks to smart optimizations implemented in the hardware that allow it to quickly discard entire blocks of pixels at a time before computing their color and writing them to memory.&lt;/p&gt;
&lt;h1&gt;Rendering 2D graphics like a 3D game&lt;/h1&gt;
&lt;p&gt;Lyon in it's current state is not a 2D rendering engine. It is mainly a way to take vector graphics primitives such as paths, and turn them into triangle meshes in a format that is straightforward to render on the GPU (but lyon doesn't implement the GPU bits at this point). The process of turning paths into triangle meshes is called &lt;em&gt;tessellation&lt;/em&gt; (some also use the word &lt;em&gt;triangulation&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img alt="Lyon logo as a triangle mesh" src="https://nical.github.io/images/lyon-logo-tessellated.png"&gt;&lt;/p&gt;
&lt;p&gt;If there is a beautiful thing about leveraging the GPU's triangle rasterization pipeline, is that since rendering becomes similar to a video game, we can use the graphics hardware exactly the way it has been meant to be used and benefit from many years of rendering tricks and optimizations from the games industry.&lt;/p&gt;
&lt;p&gt;The front to back depth buffer trick I mentioned earlier is not actually something implemented in lyon. It is just a very common optimization in 3D game engines which applies naturally when rendering paths tessellated using lyon. It is also a technique we use in &lt;a href="https://github.com/servo/webrender"&gt;webrender&lt;/a&gt; to great effects, and (spoiler alert) it's also &lt;a href="https://github.com/pcwalton/pathfinder"&gt;pathfinder&lt;/a&gt;'s most significant optimization for large paths.&lt;/p&gt;
&lt;p&gt;This is only one of the many tricks that we can learn from games. Game developers have come up with interesting approaches to anti-aliasing, various graphics effects, animation, handling thousands of individual objects and many more challenges which we can apply to our own needs.&lt;/p&gt;
&lt;h1&gt;À suivre...&lt;/h1&gt;
&lt;p&gt;This was part two. We had a superficial look at 2D rendering on the CPU and I argued that there are some benefits to picking a games-like approach to rendering on the GPU.
In the next post we will delve into lyon's tessellation algorithm itself.&lt;/p&gt;</content><category term="lyon, rust"></category></entry><entry><title>RustFest Paris - Part 1 - Intro</title><link href="https://nical.github.io/posts/rustfest-paris-01.html" rel="alternate"></link><published>2018-06-18T00:00:00+02:00</published><updated>2018-06-18T00:00:00+02:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2018-06-18:/posts/rustfest-paris-01.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;RustFest organizer: "Are you ready?"&lt;/p&gt;
&lt;p&gt;Me: "Almost."&lt;/p&gt;
&lt;p&gt;(reinstalling Xorg on my laptop 20 minutes before the talk because the window manager would not start)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I gave a talk about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt; at &lt;a href="https://paris.rustfest.eu/"&gt;RustFest Paris&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The recordings are already online, so you can watch it &lt;a href="https://app.media.ccc.de/v/rustfest18-7-vector_graphics_rendering_on_the_gpu_in_rust_with_lyon"&gt;here&lt;/a&gt; or on &lt;a href="https://www.youtube.com/watch?v=2Ng5kpDirDI&amp;amp;list=PL85XCvVPmGQgdqz9kz6qH3SI_hp7Zb4s1&amp;amp;index=7"&gt;YouTube&lt;/a&gt; if you prefer …&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;RustFest organizer: "Are you ready?"&lt;/p&gt;
&lt;p&gt;Me: "Almost."&lt;/p&gt;
&lt;p&gt;(reinstalling Xorg on my laptop 20 minutes before the talk because the window manager would not start)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I gave a talk about &lt;a href="https://github.com/nical/lyon"&gt;lyon&lt;/a&gt; at &lt;a href="https://paris.rustfest.eu/"&gt;RustFest Paris&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The recordings are already online, so you can watch it &lt;a href="https://app.media.ccc.de/v/rustfest18-7-vector_graphics_rendering_on_the_gpu_in_rust_with_lyon"&gt;here&lt;/a&gt; or on &lt;a href="https://www.youtube.com/watch?v=2Ng5kpDirDI&amp;amp;list=PL85XCvVPmGQgdqz9kz6qH3SI_hp7Zb4s1&amp;amp;index=7"&gt;YouTube&lt;/a&gt; if you prefer.&lt;/p&gt;
&lt;p&gt;&lt;img alt="lets talk about vector graphics svg" src="https://nical.github.io/images/rustfest/intro.svg"&gt;&lt;/p&gt;
&lt;p&gt;Even though I didn't feel super good about the flow of my speech this time around, I think that the talk was well received and the last minute "let's fix my window manager" episode didn't turn into a disaster.&lt;/p&gt;
&lt;p&gt;It motivated me to write a series of short blog posts about the content of the talk, and explain in more details the information which I was delivering in a hurry in the hope that I wouldn't blow up the talk's allocated time slice. Most of the images in this series of posts are slides from the presentation (made in SVG with Inkscape), but there will be additional content too.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="rustfest-paris-01.html"&gt;Part 1 - Intro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="rustfest-paris-02.html"&gt;Part 2 - Path rendering challenges&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 3 - Lyon's path tessellation algorithm&lt;/li&gt;
&lt;li&gt;Part 4 - Other GPU rendering approaches.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post is the introduction of the talk, wherein I introduce vector graphics and try to get the audience somewhat excited about it. Things will get technical in the follow-up posts.&lt;/p&gt;
&lt;h1&gt;RustFest&lt;/h1&gt;
&lt;p&gt;Before I delve into the talk, I'd like to thank the organizers for their great work on RustFest. I can only begin to imagine how stressful and exhausting it can be to organize such an event and I believe it paid off. I had a great time and I believe the other attendees did as well.&lt;/p&gt;
&lt;h1&gt;Raster graphics and vector graphics&lt;/h1&gt;
&lt;p&gt;Before I delve into lyon, let's get the terminology straight. Raster graphics is what typically comes to mind when thinking about images: a uniform grid of pixels where the color of each pixel is specified independently. Working with uniform grids has a lot of nice properties, for example having random-access in the content of the image to sample the color at a particular point, and being able to perform complex operations that sort of rely on random access like convolution filters.&lt;/p&gt;
&lt;p&gt;On the other hand raster images force authors to think about the resolution at which content is produced versus resolution at which it is presented (the output resolution of a screen for example), and they don't always happen to line up perfectly. So what happens when a 800x450 pixels image has to fill a 2560x1440 pixels screen? In most cases the image will look either blurrier or pixelated. At high resolutions, raster images occupy a lot of space. Image compression formats (png, jpeg and more modern successors) do their best to mitigate that in clever ways but size remains a limiting factor when dealing with large amounts of high resolution raster images, be it in terms of disk pass, or network bandwidth.&lt;/p&gt;
&lt;p&gt;&lt;img alt="slide raster vs vector" src="https://nical.github.io/images/rustfest/rstr-vctr.svg"&gt;&lt;/p&gt;
&lt;p&gt;Fortunately, specifying 2D content pixel by pixel is not the only choice we have at our disposal. In a lot of cases we can author and distribute not the resulting image but the steps to produce it. In very broad terms this is what I refer to when talking about vector graphics.&lt;/p&gt;
&lt;p&gt;Think of the SVG format which can be produced with Inkscape or illustrator. With vector graphics instead of specifying a grid of pixel colors you deal in terms of squares, circles, shapes, polygons, bézier curves, which you can fill and stroke with different types of patterns such as solid colors and gradients. Of course these shapes will eventually get rasterized into a raster image since that's what your screen understands, but the description of vector graphics allows to a great extent to be resolution-independent and happens to be very compact (since specifying a red square requires a small amount of data no matter how many pixels this square will eventually cover).&lt;/p&gt;
&lt;p&gt;Beyond SVG, I consider HTML/CSS to be a vector graphics format, since it is built around the idea of describing how to display 2D content rather than specifying each pixel individually.&lt;/p&gt;
&lt;p&gt;The little shape in the image above doesn't look like much but add many more and you can end up with complex drawings like the famous GhostScript tiger which inevitably appears in any presentation on the topic of vector graphics.&lt;/p&gt;
&lt;p&gt;&lt;img alt="tiger" src="https://nical.github.io/images/rustfest/tiger.svg"&gt;&lt;/p&gt;
&lt;h1&gt;Vector graphics everywhere&lt;/h1&gt;
&lt;p&gt;Today graphical applications all make use of vector graphics. Fonts are almost always described with vector formats, user interfaces, just like web pages need to be described in a way that adapts to various layouts and resolutions, a problem that vector graphics lends itself to addressing naturally.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ui slide" src="https://nical.github.io/images/rustfest/ui.svg"&gt;&lt;/p&gt;
&lt;p&gt;Using a vector format to describe maps avoids spending a lot of network bandwidth on all of these pixels and lets you zoom in and out of a map without seeing a blurry mess (unless the application is unable to render the map at interactive frame rate and choses to show you a scaled version of the previous frame while it renders the new one).&lt;/p&gt;
&lt;p&gt;&lt;img alt="maps" src="https://nical.github.io/images/rustfest/map.svg"&gt;&lt;/p&gt;
&lt;p&gt;Using vector graphics in games can be useful as well. Today, 3D and 2D games come with gigabytes of assets, a huge part of it being fairly high resolution textures. This can be very inconvenient when attempting to distribute games over the network or even just fitting the game alongside the other installed apps in a relatively small drive.
Some games could also take advantage of the resolution-independence to present content at different scales for gameplay purposes or to enhance the story telling.&lt;/p&gt;
&lt;p&gt;&lt;img alt="rpg" src="https://nical.github.io/images/rustfest/rpg.svg"&gt;&lt;/p&gt;
&lt;h1&gt;Vector graphics at 60 frames per seconds&lt;/h1&gt;
&lt;p&gt;Turns out that rendering a screen-full of complex vector graphics at an interactive frame rate is challenging. Whether it is on a laptop or a phone, Screens tend to have a &lt;em&gt;lot&lt;/em&gt; of pixels. Filling this many pixels with interesting content means a fair amount of arithmetic, and involves a lot of memory accesses. To make things worse, the drawing model for 2D content is typically based on the &lt;a href="https://en.wikipedia.org/wiki/Painter%27s_algorithm"&gt;painter's algorithm&lt;/a&gt; which consists in drawing back to front, and this content is usually built upon many overlapping layers. Take a closer look at the tiger above to see what I mean. pixels tend to be written to many times (this is called overdraw), which amplifies the cost of rendering at a high resolution.&lt;/p&gt;
&lt;p&gt;&lt;img alt="screens" src="https://nical.github.io/images/rustfest/screen.svg"&gt;&lt;/p&gt;
&lt;p&gt;As a result of that a lot of applications tend to consider rendering complex vector graphics to be too expensive for high frequency updates and either bake 2D content into textures before releasing the product (a lot of games do that) or architect their rendering tech around hiding this cost, for example by rendering to intermediate surfaces at a low frequency while these surfaces are composited to the screen at a higher frequency, which allows some types of animations stay at a solid 60fps (web browsers in particular do this).&lt;/p&gt;
&lt;h1&gt;À suivre...&lt;/h1&gt;
&lt;p&gt;That's it for part one. In the next post we'll look at how games approach the problem of redrawing the entire screen with complex content at interactive frame rates. We'll see that we can take advantage of these solutions and apply them to rendering 2D vector graphics as well.&lt;/p&gt;</content><category term="lyon, rust"></category></entry><entry><title>Introduction to lyon: 2D vector graphics rendering on the GPU in rust</title><link href="https://nical.github.io/posts/lyon-intro.html" rel="alternate"></link><published>2018-01-22T00:00:00+01:00</published><updated>2018-01-22T00:00:00+01:00</updated><author><name>Nical</name></author><id>tag:nical.github.io,2018-01-22:/posts/lyon-intro.html</id><summary type="html">&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nical/lyon"&gt;Lyon&lt;/a&gt; is a side-project that I have been working on for quite a while. The goal is to play with rendering 2D vector graphics on the GPU, and it's been a lot of fun so far. I haven't talked a lot about it online (except for a couple of reddit …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://crates.io/crates/lyon"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon"&gt;&lt;img alt="doc" src="https://docs.rs/lyon/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nical/lyon"&gt;Lyon&lt;/a&gt; is a side-project that I have been working on for quite a while. The goal is to play with rendering 2D vector graphics on the GPU, and it's been a lot of fun so far. I haven't talked a lot about it online (except for a couple of reddit threads a year or two ago) so I figured it would be a good topic to get this blog started.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The logo" src="https://nical.github.io/images/lyon-logo.svg"&gt;&lt;/p&gt;
&lt;p&gt;In this post I'll talk very briefly about tessellators (lyon's biggest feature) and show a few code snippets to illustrate some of the things you can do with lyon today.&lt;/p&gt;
&lt;h2&gt;Tessellation&lt;/h2&gt;
&lt;p&gt;Path tessellation (or triangulation), in a nutshell, is taking a path (for example a &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Path2D/Path2D"&gt;canvas&lt;/a&gt; or &lt;a href="https://www.w3.org/TR/SVG/paths.html#PathData"&gt;SVG&lt;/a&gt; path) and approximating it with a set of triangles (like the way we usually represent 3d models but in 2d). While the output of the tessellator is customizable, lyon is pretty much designed for generating vertex and index buffers, which anyone working with low level graphics APIs should be familiar with. As a result we obtain geometry in a format that is very easy to work with on the GPU using the same techniques used for 3D graphics.&lt;/p&gt;
&lt;p&gt;&lt;img alt="tessellated shape" src="https://nical.github.io/images/lyon-logo-tessellated.png"&gt;&lt;/p&gt;
&lt;h2&gt;Monotone decomposition&lt;/h2&gt;
&lt;p&gt;So how do we go about tessellating a path? The three most common algorithms are &lt;a href="https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf"&gt;ear-clipping&lt;/a&gt;, &lt;a href="http://www0.cs.ucl.ac.uk/staff/m.slater/Teaching/CG/1997-98/Solutions/Trap/"&gt;trapezoidal decomposition&lt;/a&gt; and monotone decomposition. In lyon I went for the latter.&lt;/p&gt;
&lt;p&gt;Traditionally this algorithm is performed in three passes over the geometry:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first step is to partition the shape in non-self-intersecting shapes (usually using the &lt;a href="https://en.wikipedia.org/wiki/Bentley%E2%80%93Ottmann_algorithm"&gt;Bentley-Ottmann algorithm&lt;/a&gt;),&lt;/li&gt;
&lt;li&gt;then partition these into y-monotone shapes,&lt;/li&gt;
&lt;li&gt;and finally tessellate these y-monotone shapes into triangles.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I want to come back to this in greater details in another post, but I'll just mention here that lyon's fill tessellator is a bit different from the typical implementation of monotone tessellation in the way it represents paths, and runs the steps above in single pass instead of three. Diverging from the traditional implementations seems to pay off since some &lt;a href="https://github.com/nical/lyon/blob/53b6eb48f6c01e1ff8cf6c0ce4010c9019d63e39/bench/tess/src/main.rs#L154"&gt;early measurements&lt;/a&gt; show lyon to be a bit more than twice as fast as &lt;a href="https://github.com/memononen/libtess2"&gt;libtess2&lt;/a&gt;. Take this with a grain of salt, I do need to measure a much wider range of test cases before I can boast about anything, but it's encouraging and there are still a lot of low hanging fruits on the performance side of things.&lt;/p&gt;
&lt;h2&gt;Let's look at some code&lt;/h2&gt;
&lt;p&gt;The easiest way to show off some of what lyon can do for you is to look at some code snippets:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;crate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;math&lt;/span&gt;::&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;path&lt;/span&gt;::&lt;span class="n"&gt;default&lt;/span&gt;::&lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;::&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;tessellation&lt;/span&gt;::&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Build a Path.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;move_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quadratic_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cubic_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Let&amp;#39;s use our own custom vertex type instead of the default one.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cp"&gt;#[derive(Copy, Clone, Debug)]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;MyVertex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;: &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;normal&lt;/span&gt;: &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;f32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Will contain the result of the tessellation.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;VertexBuffers&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tessellator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FillTessellator&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// Compute the tessellation.&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;tessellator&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tessellate_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path_iter&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;FillOptions&lt;/span&gt;::&lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BuffersBuilder&lt;/span&gt;::&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;: &lt;span class="nc"&gt;FillVertex&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;MyVertex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;: &lt;span class="nc"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_array&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="n"&gt;normal&lt;/span&gt;: &lt;span class="nc"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normal&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_array&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// The tessellated geometry is ready to be uploaded to the GPU.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; -- {} vertices {} indices&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertices&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;geometry&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;indices&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Et voilà! With a fairly small amount of code you can create a path and generate the vertex/index buffers that you will be able to easily render on the GPU with glium, gfx-rs, vulkano, OpenGL, or what have you.&lt;/p&gt;
&lt;p&gt;From there to pixels on your screen, it can be very simple or very complicated, that's really up to your rendering engine. You can have a look at &lt;a href="https://github.com/nical/lyon/tree/master/examples"&gt;the examples&lt;/a&gt; in the repository to get an idea. Lyon doesn't provide a renderering engine (yet), although it is something that I want to explore eventually.&lt;/p&gt;
&lt;h2&gt;What else is there in lyon?&lt;/h2&gt;
&lt;p&gt;Lyon's fill tessellator is by far where most of the work went so far. But there are a bunch of other goodies too. There is a stroke tessellator that supports most SVG stroke properties (line caps, joins, etc.), and some specialized fill and stroke tessellators for common/simpler shapes (circles, rounded rectangles, convex polygons, polylines etc.).&lt;/p&gt;
&lt;p&gt;Lyon is split into a few crates, in a way that is transparent for people who use the main crate, but helps with taming compile times and makes it possible for people to hand-pick certain features with minimal dependencies if they wish to.&lt;/p&gt;
&lt;h3&gt;lyon::geom&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_geom"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_geom"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_geom"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_geom/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lyon's &lt;a href="https://docs.rs/lyon_geom"&gt;geom&lt;/a&gt; module implements a lot of fun math for curve and line segments in 2D (splitting, flattening, intersecting, measuring, etc.) on top of euclid.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;curve&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;QuadraticBezierSegment&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ctrl&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;curve&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;: &lt;span class="nc"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;intersection&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;curve&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_intersections&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;curve&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flattened_for_each&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Approximates the curve with a sequence of line segments such&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// that the approximation is never more than 0.01 away from the&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// theoretical curve.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;approximation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If you only need this and like minimal dependencies, just do &lt;code&gt;extern crate lyon_geom;&lt;/code&gt; instead of &lt;code&gt;use lyon::geom;&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;lyon::path&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_path"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_path"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_path"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_path/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lyon's &lt;a href="https://docs.rs/lyon_path"&gt;path&lt;/a&gt; module contains path-related data structures and algorithms.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lyon&lt;/span&gt;::&lt;span class="n"&gt;path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;::&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// The default builder, it supports segments, bézier curves and arcs in&lt;/span&gt;
&lt;span class="c1"&gt;// absolute coordinates&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;move_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quadratc_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// This builder offers the full set of SVG path commands, and translates&lt;/span&gt;
&lt;span class="c1"&gt;// them into absolute coordinates since the default path data structure&lt;/span&gt;
&lt;span class="c1"&gt;// doesn&amp;#39;t support relative coordinates.&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;with_svg&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;move_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;relative_line_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;10.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;smooth_relative_cubic_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// This one automatically flattens the path (approximates curves with&lt;/span&gt;
&lt;span class="c1"&gt;// a sequence of line_to commands) using 0.01 as tolerance threshold&lt;/span&gt;
&lt;span class="c1"&gt;// to build the approximation.&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;flattened&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;move_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cubic_bezier_to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;path_iter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;PathEvent&lt;/span&gt;::&lt;span class="n"&gt;MoveTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/*...*/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;PathEvent&lt;/span&gt;::&lt;span class="n"&gt;LineTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/*...*/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;PathEvent&lt;/span&gt;::&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/*...*/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;panic&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;unexpected curve segment {:?}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// These can be composed, you get the idea...&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;with_svg&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;flattened&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// While the builder adapters APIs provide &amp;quot;push&amp;quot;-style conversions&lt;/span&gt;
&lt;span class="c1"&gt;// between various path formats, the same kind of operations are&lt;/span&gt;
&lt;span class="c1"&gt;// provided in a &amp;quot;pull&amp;quot;-style API with iterator adapters from the&lt;/span&gt;
&lt;span class="c1"&gt;// lyon::path::iterator module.&lt;/span&gt;

&lt;span class="c1"&gt;// This path stores some curves, and the events are flattened on the&lt;/span&gt;
&lt;span class="c1"&gt;// fly by the iterator.&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path_iter&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;flattened&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Place some dots at a regular interval along a path.&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;RegularPattern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt;: &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;: &lt;span class="nc"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_tangent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_distance&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;dots&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;interval&lt;/span&gt;: &lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// Place dots 3.0 appart from one another.&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;start_offset&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path_iter&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;flattened&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.01&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;walk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start_offset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I would like to evolve this crate into a sort of swiss-army-knife of path manipulations, similar to the features &lt;a href="https://github.com/paperjs/paper.js/"&gt;paperjs&lt;/a&gt; offers, for example applying boolean operations to paths, computing convex hulls, etc.&lt;/p&gt;
&lt;p&gt;Like before, if you only want to play with paths without tessellating themyou can do &lt;code&gt;extern crate lyon_path;&lt;/code&gt; instead of &lt;code&gt;use lyon::path;&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;lyon::svg&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_svg"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_svg"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_svg"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_svg/badge.svg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This module reexports the (very good) &lt;a href="https://docs.rs/svgparser"&gt;svgparser crate&lt;/a&gt; and uses it to provide a simple to build a path from an SVG path syntax:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;::&lt;span class="n"&gt;builder&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;with_svg&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;svg&lt;/span&gt;::&lt;span class="n"&gt;path_utils&lt;/span&gt;::&lt;span class="n"&gt;build_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;svg_builder&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;M 0 0 L 10 0 L 10 10 L 0 10 z&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;lyon_tess2&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://crates.io/crates/lyon_extra"&gt;&lt;img alt="crate" src="https://meritbadge.herokuapp.com/lyon_tess2"&gt;&lt;/a&gt;
&lt;a href="https://docs.rs/lyon_extra"&gt;&lt;img alt="doc" src="https://docs.rs/lyon_tess2/badge.svg"&gt;&lt;/a&gt; -&lt;/p&gt;
&lt;p&gt;The lyon_tess2 crate is a very recent addition. It provides an alternative fill tessellator that wraps the &lt;a href="https://github.com/memononen/libtess2"&gt;libtess2&lt;/a&gt; C library. I use it mostly to have something to compare lyon against, but as the two tessellators don't have the exact same feature set it can be useful to others as well.&lt;/p&gt;
&lt;h3&gt;The command-line app&lt;/h3&gt;
&lt;p&gt;The repository contains command-line application that you can use to tessellate SVG paths in your favorite terminal, render paths, flattend paths, fuzz the tessellators, find bugs, generate reduced test-cases, and maybe soon make coffee. The app could be used, for example as a tool in an art building pipeline for a game engine. It's definitely great for debugging lyon.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;lyon/cli/ $ cargo run --  show -i ../assets/logo.path --fill --stroke --tolerance &lt;span class="m"&gt;0&lt;/span&gt;.01
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img alt="screenshot" src="https://nical.github.io/images/lyon-cli-screenshot.png"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;lyon/cli/ $ cargo run --  tessellate &lt;span class="s2"&gt;&amp;quot;M 0 0 L 1 0 L 1 1 L 0 1 Z&amp;quot;&lt;/span&gt; --fill
vertices: &lt;span class="o"&gt;[(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;, &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;, &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;, &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;, &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)]&lt;/span&gt;
indices: &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;, &lt;span class="m"&gt;0&lt;/span&gt;, &lt;span class="m"&gt;2&lt;/span&gt;, &lt;span class="m"&gt;1&lt;/span&gt;, &lt;span class="m"&gt;2&lt;/span&gt;, &lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;What's next?&lt;/h2&gt;
&lt;p&gt;There are many things that I'd like to see happening in the project, and it will certainly take a long time for most of them to concretise as time is a scarse resource.&lt;/p&gt;
&lt;h3&gt;Polish the fill tessellator&lt;/h3&gt;
&lt;p&gt;The fill tessellator has grown into something that I am quite happy about. It is not perfect, I definitely want to keep improving its robustness and finish implementing for the non-zero &lt;a href="https://www.w3.org/TR/SVG/painting.html#FillRuleProperty"&gt;fill rule&lt;/a&gt;, but it's already robust enough for many use cases. For example &lt;a href="http://ggez.rs"&gt;ggez&lt;/a&gt;, the rust crate to make good games easily, uses it to render polygons, and I know that a few other projects use it to make games and even to render openstreetmaps data.&lt;/p&gt;
&lt;h3&gt;A new tessellator&lt;/h3&gt;
&lt;p&gt;I want to start working on a new fill tessellator optimized for curves and able to produce a resolution-independent tessellation, probably using trapezoidal partioning like &lt;a href="https://github.com/pcwalton/pathfinder"&gt;pathfinder&lt;/a&gt;. The new tessellator will work best with curves but will not be as good for polygons as a monotone tessellator, so the current tessellator is definitely here to stay.&lt;/p&gt;
&lt;h3&gt;A high level renderer on top of lyon&lt;/h3&gt;
&lt;p&gt;This was my initial goal when the project started forever ago. As it turns out tessellation was a fascinatingly and hard topic and I decided to focus on it for a while. It would be great to play with a 2D renderer for interactive content (like games and &lt;a href="https://beesandbombs.tumblr.com/"&gt;creative coding&lt;/a&gt;) and see what a 2D API designed for your GPU would look like (as opposed to GPU backends for APIs that were designed for CPUs a decade or two ago for static content, which is the state of most 2D APIs these days).&lt;/p&gt;
&lt;h3&gt;Documentation&lt;/h3&gt;
&lt;p&gt;There was a big documentation push a year ago and it was worth it. Let's do this again.&lt;/p&gt;
&lt;h3&gt;Maybe the next feature is going to be your idea&lt;/h3&gt;
&lt;p&gt;Or even your next pull request, Who knows?&lt;/p&gt;
&lt;h2&gt;Big thanks to all contributors&lt;/h2&gt;
&lt;p&gt;Now is a good time to underline that I didn't do all of this work alone. I want to thank again all the &lt;a href="https://github.com/nical/lyon/wiki/Contributors#contributors"&gt;awesome individuals&lt;/a&gt; who submitted contributions, big and small, to the project. This project is too large for a single person's spare time, and seeing people come and give a hand is the most rewarding and motivating thing. Also thanks a lot to everyone who is using lyon and reporting bugs!&lt;/p&gt;
&lt;p&gt;Want to join the fun? Check out the &lt;a href="https://github.com/nical/lyon/blob/master/CONTRIBUTING.md"&gt;contribution guidelines&lt;/a&gt;, get started on the &lt;a href="https://github.com/nical/lyon/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22"&gt;easier issues&lt;/a&gt;, and don't hesitate to ask any question on &lt;a href="https://gitter.im/lyon-rs/Lobby"&gt;gitter&lt;/a&gt; or irc in #rust-gamedev.
I want this project to be as fun and welcoming as possible and I would love it to be more of a team effort than a one man show. If you are running into issues contribting, &lt;a href="https://github.com/nical/lyon/issues/32"&gt;let me know&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="lyon stickers photo" src="https://nical.github.io/images/lyon-stickers.jpg"&gt;&lt;/p&gt;
&lt;p&gt;There are lyon stickers which is the ultimate proof that the project is cool.&lt;/p&gt;</content><category term="lyon, rust"></category></entry></feed>